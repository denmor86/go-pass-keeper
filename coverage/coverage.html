
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go-pass-keeper/cmd/client/main.go (0.0%)</option>
				
				<option value="file1">go-pass-keeper/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">go-pass-keeper/internal/app/app.go (0.0%)</option>
				
				<option value="file3">go-pass-keeper/internal/grpcclient/config/config.go (87.5%)</option>
				
				<option value="file4">go-pass-keeper/internal/grpcclient/interceptors/auth.go (0.0%)</option>
				
				<option value="file5">go-pass-keeper/internal/grpcclient/keeper.go (88.4%)</option>
				
				<option value="file6">go-pass-keeper/internal/grpcclient/settings/settings.go (0.0%)</option>
				
				<option value="file7">go-pass-keeper/internal/grpcclient/user.go (80.0%)</option>
				
				<option value="file8">go-pass-keeper/internal/grpcserver/config/server.go (0.0%)</option>
				
				<option value="file9">go-pass-keeper/internal/grpcserver/interceptors/interceptors.go (0.0%)</option>
				
				<option value="file10">go-pass-keeper/internal/grpcserver/server.go (0.0%)</option>
				
				<option value="file11">go-pass-keeper/internal/models/info.go (0.0%)</option>
				
				<option value="file12">go-pass-keeper/internal/models/secrets.go (78.9%)</option>
				
				<option value="file13">go-pass-keeper/internal/services/keeper.go (93.3%)</option>
				
				<option value="file14">go-pass-keeper/internal/services/user.go (77.3%)</option>
				
				<option value="file15">go-pass-keeper/internal/storage/mocks/storage_mock.go (0.0%)</option>
				
				<option value="file16">go-pass-keeper/internal/storage/postgres.go (0.0%)</option>
				
				<option value="file17">go-pass-keeper/internal/storage/secrets.go (0.0%)</option>
				
				<option value="file18">go-pass-keeper/internal/storage/user.go (0.0%)</option>
				
				<option value="file19">go-pass-keeper/internal/token/token.go (87.5%)</option>
				
				<option value="file20">go-pass-keeper/internal/tui/messages/secrets.go (0.0%)</option>
				
				<option value="file21">go-pass-keeper/internal/tui/models/add.go (0.0%)</option>
				
				<option value="file22">go-pass-keeper/internal/tui/models/app.go (0.0%)</option>
				
				<option value="file23">go-pass-keeper/internal/tui/models/auth.go (0.0%)</option>
				
				<option value="file24">go-pass-keeper/internal/tui/models/card.go (0.0%)</option>
				
				<option value="file25">go-pass-keeper/internal/tui/models/file.go (0.0%)</option>
				
				<option value="file26">go-pass-keeper/internal/tui/models/password.go (0.0%)</option>
				
				<option value="file27">go-pass-keeper/internal/tui/models/register.go (0.0%)</option>
				
				<option value="file28">go-pass-keeper/internal/tui/models/settings.go (0.0%)</option>
				
				<option value="file29">go-pass-keeper/internal/tui/models/text.go (0.0%)</option>
				
				<option value="file30">go-pass-keeper/internal/tui/models/viewer.go (0.0%)</option>
				
				<option value="file31">go-pass-keeper/pkg/crypto/crypto.go (82.5%)</option>
				
				<option value="file32">go-pass-keeper/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file33">go-pass-keeper/pkg/proto/keeper.pb.go (0.0%)</option>
				
				<option value="file34">go-pass-keeper/pkg/proto/keeper_grpc.pb.go (0.0%)</option>
				
				<option value="file35">go-pass-keeper/pkg/proto/mocks/keeper_grpc.pb_mock.go (0.0%)</option>
				
				<option value="file36">go-pass-keeper/pkg/proto/mocks/user_grpc.pb_mock.go (0.0%)</option>
				
				<option value="file37">go-pass-keeper/pkg/proto/user.pb.go (0.0%)</option>
				
				<option value="file38">go-pass-keeper/pkg/proto/user_grpc.pb.go (0.0%)</option>
				
				<option value="file39">go-pass-keeper/pkg/usercontext/usercontext.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "go-pass-keeper/internal/grpcclient/config"
        "go-pass-keeper/internal/tui/models"
        "go-pass-keeper/pkg/logger"

        tea "github.com/charmbracelet/bubbletea"
)

var (
        buildVersion string = "N/A" // номер версии
        buildDate    string = "N/A" // дата сборки
        buildCommit  string = "N/A" // хэш комита
)

func makeBuildInfo() string <span class="cov0" title="0">{
        shortCommit := buildCommit
        if len(buildCommit) &gt;= 7 </span><span class="cov0" title="0">{
                shortCommit = buildCommit[:7]
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Build: %s(%s) %s",
                buildVersion, shortCommit, buildDate)</span>
}

func main() <span class="cov0" title="0">{

        config := config.NewConfig("go-pass-keeper")
        p := tea.NewProgram(models.NewAppModel(config, makeBuildInfo()), tea.WithAltScreen())
        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Error run GophKeeper: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "go-pass-keeper/internal/app"
        "go-pass-keeper/internal/grpcserver/config"
        "go-pass-keeper/pkg/logger"
)

// функция main вызывается автоматически при запуске приложения
func main() <span class="cov0" title="0">{
        config := config.NewConfig()
        defer logger.Sync()

        a := app.NewApp(config)

        a.Run()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package app предоставляет реализацию инициализацию приложение
// Включает инициализацию конфига и логгера, создание сервера, запуск воркера.
package app

import (
        "fmt"
        "go-pass-keeper/internal/grpcserver"
        "go-pass-keeper/internal/grpcserver/config"
        interceptors "go-pass-keeper/internal/grpcserver/interceptors"
        "go-pass-keeper/internal/services"
        "go-pass-keeper/internal/storage"
        "go-pass-keeper/internal/token"
        "go-pass-keeper/pkg/logger"
        "os"
        "os/signal"
        "syscall"

        "github.com/pkg/errors"
)

// App - модель данных приложения
type App struct {
        config *config.Config
        server *grpcserver.Server
}

// NewApp - создаёт новый сервер, где params - набор параметров
func NewApp(cfg *config.Config) *App <span class="cov0" title="0">{
        return &amp;App{config: cfg}
}</span>

// Run - иницилизация приложения и запуска сервера обработки сообщений
func (a *App) Run() <span class="cov0" title="0">{
        if err := logger.Initialize(a.config.LogLevel); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("can't initialize logger: %s ", errors.Cause(err).Error()))</span>
        }

        <span class="cov0" title="0">logger.Info(
                "Starting server config:", a.config,
        )

        th, err := token.NewJWT(a.config.JWTSecret)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error token handler", err.Error())
        }</span>
        <span class="cov0" title="0">db, err := storage.NewDatabase(a.config.DatabaseDSN)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error create database", err.Error())
        }</span>
        <span class="cov0" title="0">err = db.Initialize()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error initialize database", err.Error())
        }</span>
        // хранилище пользователей
        <span class="cov0" title="0">users := storage.NewUserStorage(db)
        // хранилище секретов
        secrets := storage.NewSecretStorage(db)
        // сервис пользователей
        us := services.NewUser(users, th)
        // сервис секретов
        ks := services.NewKeeper(secrets)
        a.server = grpcserver.NewServer(
                // адрес
                grpcserver.UseListenAddr(a.config.ListenAddr),
                // перехватчики обычные запросов
                grpcserver.UseUnaryInterceptors(interceptors.CreateUnaryInterceptors(th)...),
                // перехватчики потоковых запросов
                grpcserver.UseStreamInterceptors(interceptors.CreateStreamInterceptors(th)...),
                // используемые сервисы
                grpcserver.UseServices(us, ks),
        )

        if err := a.server.Start(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Error start server", err.Error())
        }</span>

        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT)

        // Ждем сигнал остановки
        &lt;-stop
        logger.Info("Shutdown signal received")

        close(stop)
        a.server.Stop()
        logger.Info("Shutdown completed")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "encoding/json"
        "go-pass-keeper/internal/grpcclient/settings"
        "os"
        "path/filepath"
)

// Config - модель конфига
type Config struct {
        configPath string
}

// NewConfig - метод создания нового конфига из файла
func NewConfig(appName string) *Config <span class="cov8" title="1">{
        configDir, _ := os.UserConfigDir()
        configPath := filepath.Join(configDir, appName, "config.json")
        return &amp;Config{configPath: configPath}
}</span>

// Load - загрузка конфига из файла
func (cm *Config) Load() *settings.Settings <span class="cov8" title="1">{
        data, err := os.ReadFile(cm.configPath)
        if err != nil </span><span class="cov0" title="0">{
                return cm.DefaultConfig()
        }</span>

        <span class="cov8" title="1">config := cm.DefaultConfig()
        if json.Unmarshal(data, config) != nil </span><span class="cov8" title="1">{
                return config
        }</span>

        <span class="cov8" title="1">return config</span>
}

// Load - сохранение конфига в файл
func (cm *Config) Save(config *settings.Settings) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">os.MkdirAll(filepath.Dir(cm.configPath), 0755)
        return os.WriteFile(cm.configPath, data, 0644)</span>
}

// DefaultConfig - дефолтный конфиг
func (cm *Config) DefaultConfig() *settings.Settings <span class="cov8" title="1">{
        return &amp;settings.Settings{
                ServerURL:  "localhost",
                ServerPort: "8080",
                Timeout:    30,
                Secret:     "secret",
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package interceptors

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
)

const (
        headerAuthorize = "authorization"
)

// AuthInterceptor - метод интерсептор для авторизации в обычных запросах
func AuthInterceptor(
        token string,
) grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                method string,
                req, reply any,
                cc *grpc.ClientConn,
                invoker grpc.UnaryInvoker,
                opts ...grpc.CallOption,
        ) error </span><span class="cov0" title="0">{
                if len(token) == 0 </span><span class="cov0" title="0">{
                        return invoker(ctx, method, req, reply, cc, opts...)
                }</span>

                <span class="cov0" title="0">authorize := "bearer " + token
                ctx = metadata.NewOutgoingContext(ctx, metadata.Pairs(headerAuthorize, authorize))

                return invoker(ctx, method, req, reply, cc, opts...)</span>
        }
}

// AuthStreamInterceptor - метод интерсептор для авторизации в потоковых запросах
func AuthStreamInterceptor(
        token string,
) grpc.StreamClientInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                desc *grpc.StreamDesc,
                cc *grpc.ClientConn,
                method string,
                streamer grpc.Streamer,
                opts ...grpc.CallOption,
        ) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                if len(token) == 0 </span><span class="cov0" title="0">{
                        return streamer(ctx, desc, cc, method, opts...)
                }</span>

                <span class="cov0" title="0">authorize := "bearer " + token
                ctx = metadata.NewOutgoingContext(ctx, metadata.Pairs(headerAuthorize, authorize))

                return streamer(ctx, desc, cc, method, opts...)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package grpcclient

import (
        "context"
        "fmt"
        "go-pass-keeper/internal/grpcclient/interceptors"
        "go-pass-keeper/internal/models"
        "go-pass-keeper/pkg/logger"
        pb "go-pass-keeper/pkg/proto"
        "net/url"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"
)

// KeeperClient модель клиента для работы с секретами
type KeeperClient struct {
        serverAddr string
        conn       *grpc.ClientConn
        client     pb.KeeperClient
        opts       []grpc.DialOption
        ctx        context.Context
        token      string
}

// KeeperClientOption определяет тип для опций
type KeeperClientOption func(*KeeperClient)

// NewKeeperClient - метод создает новый экземпляр KeeperClient
func NewKeeperClient(serverAddr string, token string, opts ...KeeperClientOption) *KeeperClient <span class="cov8" title="1">{
        client := &amp;KeeperClient{
                serverAddr: serverAddr,
                opts: []grpc.DialOption{
                        grpc.WithTransportCredentials(insecure.NewCredentials()),
                        grpc.WithUnaryInterceptor(interceptors.AuthInterceptor(token)),
                        grpc.WithStreamInterceptor(interceptors.AuthStreamInterceptor(token)),
                },
                token: token,
        }

        // Применяем переданные опции
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(client)
        }</span>

        <span class="cov8" title="1">return client</span>
}

// UseKeeperOptions - метод добавляет дополнительные grpc опции
func UseKeeperOptions(opts ...grpc.DialOption) KeeperClientOption <span class="cov0" title="0">{
        return func(uc *KeeperClient) </span><span class="cov0" title="0">{
                uc.opts = append(uc.opts, opts...)
        }</span>
}

// Connect - метод устанавливает соединение с сервером
func (uc *KeeperClient) Connect(ctx context.Context) error <span class="cov8" title="1">{
        _, err := url.ParseRequestURI(uc.serverAddr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid server address: %w", err)
        }</span>
        <span class="cov8" title="1">conn, err := grpc.NewClient(uc.serverAddr, uc.opts...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to connect to server", err.Error())
                return fmt.Errorf("failed to connect: %w", err)
        }</span>

        <span class="cov8" title="1">uc.conn = conn
        uc.client = pb.NewKeeperClient(conn)
        uc.ctx = ctx
        return nil</span>
}

// Close - метод закрывает соединение
func (uc *KeeperClient) Close() error <span class="cov0" title="0">{
        if uc.conn != nil </span><span class="cov0" title="0">{
                return uc.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AddSecret - метод добавляет секрет
func (uc *KeeperClient) AddSecret(info *models.SecretInfo, content []byte) (*models.SecretInfo, error) <span class="cov8" title="1">{
        if info == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid info")
        }</span>
        <span class="cov8" title="1">if uc.client == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("client not connected")
        }</span>
        <span class="cov8" title="1">resp, err := uc.client.AddSecret(uc.ctx,
                &amp;pb.AddSecretRequest{
                        Meta:    info.ToProtoMetadata(),
                        Content: content},
        )
        switch status.Code(err) </span>{
        case codes.OK:<span class="cov8" title="1">
                return models.SecretInfoFromProtoMetadata(resp.GetMeta()), nil</span>
        case codes.Unauthenticated:<span class="cov8" title="1">
                logger.Warn("User unauthenticated", err.Error())
                return nil, fmt.Errorf("user unauthenticated")</span>
        default:<span class="cov8" title="1">
                logger.Warn("Add secret error", err.Error())
                return nil, fmt.Errorf("internal error")</span>
        }
}

// GetSecret - метод получает содержимое секрета пользователя
func (uc *KeeperClient) GetSecret(sid string) (*models.SecretInfo, []byte, error) <span class="cov8" title="1">{
        if uc.client == nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("client not connected")
        }</span>
        <span class="cov8" title="1">resp, err := uc.client.GetSecret(uc.ctx, &amp;pb.GetSecretRequest{Meta: &amp;pb.SecretMetadata{Id: sid}})
        switch status.Code(err) </span>{
        case codes.OK:<span class="cov8" title="1">
                return models.SecretInfoFromProtoMetadata(resp.GetMeta()), resp.GetContent(), nil</span>
        case codes.Unauthenticated:<span class="cov8" title="1">
                logger.Warn("User unauthenticated", err.Error())
                return nil, nil, fmt.Errorf("user unauthenticated")</span>
        default:<span class="cov8" title="1">
                logger.Warn("Get secret error", err.Error())
                return nil, nil, fmt.Errorf("internal error")</span>
        }
}

// GetSecrets - метод получает список секретов пользователя
func (uc *KeeperClient) GetSecrets() ([]*models.SecretInfo, error) <span class="cov8" title="1">{
        if uc.client == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("client not connected")
        }</span>
        <span class="cov8" title="1">resp, err := uc.client.GetSecrets(uc.ctx, &amp;pb.GetSecretsRequest{})
        switch status.Code(err) </span>{
        case codes.OK:<span class="cov8" title="1">
                return models.SecretsResponseToSecretInfo(resp), nil</span>
        case codes.Unauthenticated:<span class="cov8" title="1">
                logger.Warn("User unauthenticated", err.Error())
                return nil, fmt.Errorf("user unauthenticated")</span>
        default:<span class="cov8" title="1">
                logger.Warn("Get secrets error", err.Error())
                return nil, fmt.Errorf("internal error")</span>
        }
}

// DeleteSecret - метод удаляет секрет
func (uc *KeeperClient) DeleteSecret(sid string) (string, error) <span class="cov8" title="1">{
        if uc.client == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("client not connected")
        }</span>
        <span class="cov8" title="1">resp, err := uc.client.DeleteSecret(uc.ctx, &amp;pb.DeleteSecretRequest{Meta: &amp;pb.SecretMetadata{Id: sid}})
        switch status.Code(err) </span>{
        case codes.OK:<span class="cov8" title="1">
                return resp.GetMeta().GetId(), nil</span>
        case codes.Unauthenticated:<span class="cov8" title="1">
                logger.Warn("User unauthenticated", err.Error())
                return "", fmt.Errorf("user unauthenticated")</span>
        default:<span class="cov8" title="1">
                logger.Warn("Secret delete error", err.Error())
                return "", fmt.Errorf("internal error")</span>
        }
}

// EditSecret - метод редактирует секрет
func (uc *KeeperClient) EditSecret(info *models.SecretInfo, content []byte) (*models.SecretInfo, error) <span class="cov8" title="1">{
        if info == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid info")
        }</span>
        <span class="cov8" title="1">if uc.client == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("client not connected")
        }</span>
        <span class="cov8" title="1">resp, err := uc.client.EditSecret(uc.ctx,
                &amp;pb.EditSecretRequest{
                        Meta:    info.ToProtoMetadata(),
                        Content: content},
        )
        switch status.Code(err) </span>{
        case codes.OK:<span class="cov8" title="1">
                return models.SecretInfoFromProtoMetadata(resp.GetMeta()), nil</span>
        case codes.Unauthenticated:<span class="cov8" title="1">
                logger.Warn("User unauthenticated", err.Error())
                return nil, fmt.Errorf("user unauthenticated")</span>
        default:<span class="cov8" title="1">
                logger.Warn("Edit secret error", err.Error())
                return nil, fmt.Errorf("internal error")</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package settings

import (
        "fmt"
)

// Settings - модель настроек подключения
type Settings struct {
        ServerURL  string `json:"server_url"`
        ServerPort string `json:"server_port"`
        Timeout    int    `json:"timeout"`
        Secret     string // не сохраняем для секурности
}

// ServerAddress - формирование строки адреса сервера
func (s *Settings) ServerAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", s.ServerURL, s.ServerPort)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package grpcclient

import (
        "context"
        "fmt"
        "go-pass-keeper/pkg/logger"
        pb "go-pass-keeper/pkg/proto"
        "net/url"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"
)

// UserClient модель клиента для работы с пользователем
type UserClient struct {
        serverAddr string
        conn       *grpc.ClientConn
        client     pb.UserClient
        opts       []grpc.DialOption
        ctx        context.Context
}

// UserClientOption определяет тип для опций
type UserClientOption func(*UserClient)

// NewUserClient - метод создает новый экземпляр UserClient
func NewUserClient(serverAddr string, opts ...UserClientOption) *UserClient <span class="cov8" title="1">{
        client := &amp;UserClient{
                serverAddr: serverAddr,
                opts:       []grpc.DialOption{grpc.WithTransportCredentials(insecure.NewCredentials())},
        }

        // Применяем переданные опции
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(client)
        }</span>

        <span class="cov8" title="1">return client</span>
}

// UseUserOptions - метод добавляет дополнительные grpc опции
func UseUserOptions(opts ...grpc.DialOption) UserClientOption <span class="cov0" title="0">{
        return func(uc *UserClient) </span><span class="cov0" title="0">{
                uc.opts = append(uc.opts, opts...)
        }</span>
}

// Connect - метод устанавливает соединение с сервером
func (uc *UserClient) Connect(ctx context.Context) error <span class="cov8" title="1">{
        _, err := url.ParseRequestURI(uc.serverAddr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid server address: %w", err)
        }</span>
        <span class="cov8" title="1">conn, err := grpc.NewClient(uc.serverAddr, uc.opts...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to connect to server", err.Error())
                return fmt.Errorf("failed to connect: %w", err)
        }</span>

        <span class="cov8" title="1">uc.conn = conn
        uc.client = pb.NewUserClient(conn)
        uc.ctx = ctx
        return nil</span>
}

// Close - метод закрывает соединение
func (uc *UserClient) Close() error <span class="cov0" title="0">{
        if uc.conn != nil </span><span class="cov0" title="0">{
                return uc.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Register - метод регистрирует нового пользователя
func (uc *UserClient) Register(login string, password string) (string, string, error) <span class="cov8" title="1">{
        if uc.client == nil </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("client not connected")
        }</span>

        <span class="cov8" title="1">resp, err := uc.client.Register(uc.ctx, &amp;pb.RegisterRequest{
                Login:    login,
                Password: password,
        })

        switch status.Code(err) </span>{
        case codes.OK:<span class="cov8" title="1">
                logger.Info("User registered", login)
                return resp.GetToken(), resp.GetSalt(), nil</span>
        case codes.InvalidArgument:<span class="cov8" title="1">
                logger.Warn("invalid user", err.Error())
                return "", "", fmt.Errorf("invalid user")</span>
        default:<span class="cov8" title="1">
                logger.Warn("User register error", err.Error())
                return "", "", fmt.Errorf("internal error")</span>
        }
}

// Login - метод авторизует пользователя
func (uc *UserClient) Login(login, password string) (string, string, error) <span class="cov8" title="1">{
        if uc.client == nil </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("client not connected")
        }</span>

        <span class="cov8" title="1">resp, err := uc.client.Login(uc.ctx, &amp;pb.LoginRequest{
                Login:    login,
                Password: password,
        })

        switch status.Code(err) </span>{
        case codes.OK:<span class="cov8" title="1">
                logger.Info("User is authorized", login)
                return resp.GetToken(), resp.GetSalt(), nil</span>
        case codes.Unauthenticated:<span class="cov8" title="1">
                logger.Warn("User unauthenticated", err.Error())
                return "", "", fmt.Errorf("user unauthenticated")</span>
        default:<span class="cov8" title="1">
                logger.Warn("User login error", err.Error())
                return "", "", fmt.Errorf("internal error")</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "fmt"

        "github.com/caarlos0/env"
        "github.com/spf13/pflag"
)

// Config модель настроек сервера
type Config struct {
        ListenAddr  string `env:"RUN_ADDRESS" envDefault:"localhost:8080"`
        LogLevel    string `env:"LOG_LEVEL" envDefault:"info"`
        DatabaseDSN string `env:"DATABASE_URI" envDefault:""`
        JWTSecret   string `env:"JWT_SECRET" envDefault:"secret"`
}

// NewConfig - создание новой конфигурации
func NewConfig() *Config <span class="cov0" title="0">{

        var args Config
        if err := env.Parse(&amp;args); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to parse enviroment var: %s", err.Error()))</span>
        }

        <span class="cov0" title="0">var (
                server   = pflag.StringP("server", "a", args.ListenAddr, "Server listen address in a form host:port.")
                logLevel = pflag.StringP("log_level", "l", args.LogLevel, "Log level.")
                DSN      = pflag.StringP("dsn", "d", args.DatabaseDSN, "Database DSN")
                secret   = pflag.StringP("secret", "s", args.JWTSecret, "Secret to JWT")
        )
        pflag.Parse()

        return &amp;Config{
                ListenAddr:  *server,
                LogLevel:    *logLevel,
                DatabaseDSN: *DSN,
                JWTSecret:   *secret,
        }</span>
}
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                ListenAddr:  "localhost:8080",
                LogLevel:    "info",
                DatabaseDSN: "",
                JWTSecret:   "secret",
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package grpcserver

import (
        "context"
        "fmt"
        "go-pass-keeper/pkg/logger"
        "go-pass-keeper/pkg/usercontext"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/google/uuid"
        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/auth"
        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery"
)

// tokenHandler интефрейс для работы с токеном
type tokenHandler interface {
        // DecodeUserId - извлечение ID пользователя из токена
        DecodeUserId(token string) (string, error)
}

// MakeAuthFunc - метод создания функции авторизации для перехватчика
func MakeAuthFunc(handler tokenHandler) auth.AuthFunc <span class="cov0" title="0">{
        return func(ctx context.Context) (context.Context, error) </span><span class="cov0" title="0">{
                jwt, err := auth.AuthFromMD(ctx, "bearer")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">uid, err := handler.DecodeUserId(jwt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "invalid auth token: %v", err)
                }</span>

                <span class="cov0" title="0">u, err := uuid.Parse(uid)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "invalid auth token: %v", err)
                }</span>

                // создаем контекст, и добавляем в него ID пользователя (чтобы отвязать обработчик от парсинга cookie)
                <span class="cov0" title="0">ctx = usercontext.SetUserId(ctx, u)
                return ctx, nil</span>
        }
}

// InterceptorLogger - метод перехватчик логирования в GRPC
func InterceptorLogger(l *zap.Logger) logging.Logger <span class="cov0" title="0">{
        return logging.LoggerFunc(func(ctx context.Context, lvl logging.Level, msg string, fields ...any) </span><span class="cov0" title="0">{
                f := make([]zap.Field, 0, len(fields)/2)

                for i := 0; i &lt; len(fields); i += 2 </span><span class="cov0" title="0">{
                        key := fields[i]
                        value := fields[i+1]

                        switch v := value.(type) </span>{
                        case string:<span class="cov0" title="0">
                                f = append(f, zap.String(key.(string), v))</span>
                        case int:<span class="cov0" title="0">
                                f = append(f, zap.Int(key.(string), v))</span>
                        case bool:<span class="cov0" title="0">
                                f = append(f, zap.Bool(key.(string), v))</span>
                        default:<span class="cov0" title="0">
                                f = append(f, zap.Any(key.(string), v))</span>
                        }
                }

                <span class="cov0" title="0">logger := l.WithOptions(zap.AddCallerSkip(1)).With(f...)

                switch lvl </span>{
                case logging.LevelDebug:<span class="cov0" title="0">
                        logger.Debug(msg)</span>
                case logging.LevelInfo:<span class="cov0" title="0">
                        logger.Info(msg)</span>
                case logging.LevelWarn:<span class="cov0" title="0">
                        logger.Warn(msg)</span>
                case logging.LevelError:<span class="cov0" title="0">
                        logger.Error(msg)</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("unknown level %v", lvl))</span>
                }
        })
}

// CreateUnaryInterceptors - метод для создания перехватчиков обычных запросов
func CreateUnaryInterceptors(handler tokenHandler) []grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return []grpc.UnaryServerInterceptor{

                logging.UnaryServerInterceptor(InterceptorLogger(logger.Get().Desugar())),
                recovery.UnaryServerInterceptor(),
                auth.UnaryServerInterceptor(MakeAuthFunc(handler)),
        }
}</span>

// CreateStreamInterceptors - метод для создания перехватчиков потоковых запросов
func CreateStreamInterceptors(handler tokenHandler) []grpc.StreamServerInterceptor <span class="cov0" title="0">{
        return []grpc.StreamServerInterceptor{
                auth.StreamServerInterceptor(MakeAuthFunc(handler)),
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package grpcserver

import (
        "fmt"
        "go-pass-keeper/pkg/logger"
        "net"

        "google.golang.org/grpc"
)

// Service - интерфейс сервиса
type Service interface {
        // RegisterService - регистрация сервиса
        RegisterService(grpc.ServiceRegistrar)
}

// Server - структура сервера с использованием GRPC
type Server struct {
        listenAddr         string                         // адрес
        server             *grpc.Server                   // указатель на сервер
        services           []Service                      // сервисы
        unaryInterceptors  []grpc.UnaryServerInterceptor  // перехватчики простых запросов
        streamInterceptors []grpc.StreamServerInterceptor // перехватчики потоковых запросов
}

// Params - тип параметров
type Params func(*Server)

// UseListenAddr - метод устанавливает использования адреса сервера
func UseListenAddr(a string) Params <span class="cov0" title="0">{
        return func(server *Server) </span><span class="cov0" title="0">{
                server.listenAddr = a
        }</span>
}

// UseServices - метод устанавливает используемые сервисы
func UseServices(in ...Service) Params <span class="cov0" title="0">{
        return func(server *Server) </span><span class="cov0" title="0">{
                server.services = append(server.services, in...)
        }</span>
}

// UseUnaryInterceptors - метод устанавливает используемые интерцепторы для обычных(аутентификация, логирования и т.д)
func UseUnaryInterceptors(in ...grpc.UnaryServerInterceptor) Params <span class="cov0" title="0">{
        return func(server *Server) </span><span class="cov0" title="0">{
                server.unaryInterceptors = append(server.unaryInterceptors, in...)
        }</span>
}

// UseStreamInterceptors - метод устанавливает используемые интерцепторы для потоковых запросов
func UseStreamInterceptors(in ...grpc.StreamServerInterceptor) Params <span class="cov0" title="0">{
        return func(server *Server) </span><span class="cov0" title="0">{
                server.streamInterceptors = append(server.streamInterceptors, in...)
        }</span>
}

// NewServer - метод создаёт новый сервер, где params - набор параметров
func NewServer(params ...Params) *Server <span class="cov0" title="0">{
        s := &amp;Server{}

        // применяем параметры сервера
        for _, param := range params </span><span class="cov0" title="0">{
                param(s)
        }</span>

        <span class="cov0" title="0">return s</span>
}

// RegisterServices - метод регистририет работу сервисов в GRPC
func (s *Server) RegisterServices(services ...Service) <span class="cov0" title="0">{
        for _, service := range services </span><span class="cov0" title="0">{
                service.RegisterService(s.server)
        }</span>
}

// Start - метод запуска сервера
func (s *Server) Start() error <span class="cov0" title="0">{
        lis, err := net.Listen("tcp", s.listenAddr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error listen tcp: %w", err)
        }</span>
        // создаем сервер
        <span class="cov0" title="0">s.server = grpc.NewServer(
                grpc.ChainUnaryInterceptor(s.unaryInterceptors...),
                grpc.ChainStreamInterceptor(s.streamInterceptors...),
        )
        // регистрируем обработчики
        s.RegisterServices(s.services...)
        //  запускаем сервер
        go func() </span><span class="cov0" title="0">{
                logger.Info("Starting server on", s.listenAddr)
                if err := s.server.Serve(lis); err != nil &amp;&amp; err != grpc.ErrServerStopped </span><span class="cov0" title="0">{
                        logger.Error("Server error", err.Error())
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// Stop - метод остановки сервера
func (s *Server) Stop() <span class="cov0" title="0">{
        s.server.GracefulStop()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package models

import (
        pb "go-pass-keeper/pkg/proto"
        "time"
)

// SecretInfo - модель информации о секрете
type SecretInfo struct {
        ID      string
        Name    string
        Type    string
        Created time.Time
        Updated time.Time
}

// ToProtoMetadata - метод конвертирует информацию в метаданные
func (i *SecretInfo) ToProtoMetadata() *pb.SecretMetadata <span class="cov0" title="0">{
        return &amp;pb.SecretMetadata{
                Id:   i.ID,
                Name: i.Name,
                Type: i.Type,
        }
}</span>

func SecretInfoFromProtoMetadata(meta *pb.SecretMetadata) *SecretInfo <span class="cov0" title="0">{
        return &amp;SecretInfo{
                ID:      meta.GetId(),
                Name:    meta.GetName(),
                Type:    meta.GetType(),
                Created: meta.GetCreated().AsTime(),
                Updated: meta.GetUpdated().AsTime(),
        }
}</span>

func SecretsResponseToSecretInfo(pbSecrets *pb.GetSecretsResponse) []*SecretInfo <span class="cov0" title="0">{
        pbSecretsList := pbSecrets.GetSecrets()
        res := make([]*SecretInfo, 0, len(pbSecretsList))

        for _, s := range pbSecretsList </span><span class="cov0" title="0">{
                res = append(res, SecretInfoFromProtoMetadata(s))
        }</span>
        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "go-pass-keeper/pkg/crypto"
)

const (
        SecretPasswordType = "password"
        SecretCardType     = "card"
        SecretTextType     = "text"
        SecretBinaryType   = "binary"
)

// SecretPassword - данные логин/пароль
type SecretPassword struct {
        Login    string `json:"login"`
        Password string `json:"password"`
}

// SecretCard - данные банковская карта
type SecretCard struct {
        Number string `json:"number"`
        Date   string `json:"date"`
        CVV    string `json:"cvv"`
        Owner  string `json:"owner"`
}

// SecretCrypter - интерфейс для обобщения типов секретных данных
type SecretCrypter interface {
        Encrypt([]byte) ([]byte, error)
        Decrypt([]byte, []byte) error
}

// NewSecretPassword - базовый конструктор
func NewSecretPassword(login, password string) *SecretPassword <span class="cov8" title="1">{
        return &amp;SecretPassword{
                Login:    login,
                Password: password,
        }
}</span>

// Encrypt - метод шифрует данные пароля и логина
func (sp *SecretPassword) Encrypt(key []byte) ([]byte, error) <span class="cov8" title="1">{
        data, err := json.Marshal(sp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal: %w", err)
        }</span>
        <span class="cov8" title="1">return crypto.Encrypt(key, data)</span>
}

// Decrypt - метод рашифровывает данные пароля и логина
func (sp *SecretPassword) Decrypt(key []byte, content []byte) error <span class="cov8" title="1">{
        data, err := crypto.Decrypt(key, content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, sp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewSecretCard - базовый конструктор
func NewSecretCard(number, date, cvv, owner string) *SecretCard <span class="cov8" title="1">{
        return &amp;SecretCard{
                Number: number,
                Date:   date,
                CVV:    cvv,
                Owner:  owner,
        }
}</span>

// Encrypt - метод шифрует данные кредитной карты
func (sc *SecretCard) Encrypt(key []byte) ([]byte, error) <span class="cov8" title="1">{
        data, err := json.Marshal(sc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal: %w", err)
        }</span>
        <span class="cov8" title="1">return crypto.Encrypt(key, data)</span>
}

// Decrypt - метод рашифровывает данные кредитной карты
func (sc *SecretCard) Decrypt(key []byte, content []byte) error <span class="cov8" title="1">{
        data, err := crypto.Decrypt(key, content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, sc)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SecretText - текстовые данные
type SecretText struct {
        Text string
}

// NewSecretText - базовый конструктор
func NewSecretText(text string) *SecretText <span class="cov8" title="1">{
        return &amp;SecretText{
                Text: text,
        }
}</span>

// Encrypt - метод шифрует текстовые данные
func (sc *SecretText) Encrypt(key []byte) ([]byte, error) <span class="cov8" title="1">{
        return crypto.Encrypt(key, []byte(sc.Text))
}</span>

// Decrypt - метод рашифровывает текстовые данные
func (sc *SecretText) Decrypt(key []byte, content []byte) error <span class="cov8" title="1">{
        data, err := crypto.Decrypt(key, content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">sc.Text = string(data)
        return nil</span>
}

// SecretBinary - бинарные данные
type SecretBinary struct {
        Blob []byte
}

// NewSecretBinary- базовый конструктор
func NewSecretBinary(bin []byte) *SecretBinary <span class="cov8" title="1">{
        return &amp;SecretBinary{
                Blob: bin,
        }
}</span>

// Encrypt - метод шифрует бинарные данные
func (sc *SecretBinary) Encrypt(key []byte) ([]byte, error) <span class="cov8" title="1">{
        return crypto.Encrypt(key, sc.Blob)
}</span>

// Decrypt - метод рашифровывает бинарные данные
func (sc *SecretBinary) Decrypt(key []byte, content []byte) error <span class="cov8" title="1">{
        data, err := crypto.Decrypt(key, content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">sc.Blob = data
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package services

import (
        "context"
        "errors"
        "go-pass-keeper/internal/models"
        "go-pass-keeper/internal/storage"
        pb "go-pass-keeper/pkg/proto"
        "go-pass-keeper/pkg/usercontext"

        "github.com/google/uuid"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// Keeper - модель сервиса секретов
type Keeper struct {
        pb.UnimplementedKeeperServer

        secrets storage.Secret
}

// NewKeeper - метод создания сервиса работы с секретами
func NewKeeper(s storage.Secret) *Keeper <span class="cov8" title="1">{
        return &amp;Keeper{
                secrets: s,
        }
}</span>

// AddSecret - метод для добавления секрета
func (s *Keeper) AddSecret(ctx context.Context, request *pb.AddSecretRequest) (*pb.AddSecretResponse, error) <span class="cov8" title="1">{
        uid, err := usercontext.GetUserId(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Unauthenticated, err.Error())
        }</span>
        <span class="cov8" title="1">m := &amp;models.SecretData{
                UserID:  uid,
                Name:    request.GetMeta().GetName(),
                Type:    request.GetMeta().GetType(),
                Content: request.GetContent(),
        }
        secret, err := s.secrets.Add(ctx, m)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, storage.ErrAlreadyExists) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.AlreadyExists, err.Error())
                }</span>
                <span class="cov8" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
        }
        <span class="cov8" title="1">return &amp;pb.AddSecretResponse{Meta: &amp;pb.SecretMetadata{
                Id:      secret.ID.String(),
                Name:    m.Name,
                Type:    m.Type,
                Created: timestamppb.New(secret.Created),
                Updated: timestamppb.New(secret.Updated)}}, nil</span>
}

// GetSecret - метод для получения секрета пользователя
func (s *Keeper) GetSecret(ctx context.Context, request *pb.GetSecretRequest) (*pb.GetSecretResponse, error) <span class="cov8" title="1">{
        _, err := usercontext.GetUserId(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Unauthenticated, err.Error())
        }</span>
        <span class="cov8" title="1">sid, err := uuid.Parse(request.GetMeta().GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>
        <span class="cov8" title="1">secret, err := s.secrets.Get(ctx, sid)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, storage.ErrNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, err.Error())
                }</span>
                <span class="cov8" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
        }
        <span class="cov8" title="1">return &amp;pb.GetSecretResponse{Meta: &amp;pb.SecretMetadata{
                Id:      secret.ID.String(),
                Name:    secret.Name,
                Type:    secret.Type,
                Created: timestamppb.New(secret.Created),
                Updated: timestamppb.New(secret.Updated)},
                Content: secret.Content}, nil</span>
}

// DeleteSecret - метод удаления секрета пользователя
func (s *Keeper) DeleteSecret(ctx context.Context, request *pb.DeleteSecretRequest) (*pb.DeleteSecretResponse, error) <span class="cov8" title="1">{
        _, err := usercontext.GetUserId(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Unauthenticated, err.Error())
        }</span>
        <span class="cov8" title="1">sid, err := uuid.Parse(request.GetMeta().GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>
        <span class="cov8" title="1">if err := s.secrets.Delete(ctx, sid); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, storage.ErrNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, err.Error())
                }</span>
                <span class="cov8" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
        }

        <span class="cov8" title="1">return &amp;pb.DeleteSecretResponse{Meta: request.GetMeta()}, nil</span>
}

// GetSecrets - метод получения информации о секретах пользователя
func (s *Keeper) GetSecrets(ctx context.Context, request *pb.GetSecretsRequest) (*pb.GetSecretsResponse, error) <span class="cov8" title="1">{
        uid, err := usercontext.GetUserId(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Unauthenticated, err.Error())
        }</span>

        <span class="cov8" title="1">list, err := s.secrets.List(ctx, uid)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, storage.ErrNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, err.Error())
                }</span>
                <span class="cov8" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
        }

        <span class="cov8" title="1">resp := &amp;pb.GetSecretsResponse{}
        for _, secret := range list </span><span class="cov8" title="1">{
                resp.Secrets = append(resp.Secrets, &amp;pb.SecretMetadata{
                        Id:      secret.ID.String(),
                        Name:    secret.Name,
                        Type:    secret.Type,
                        Created: timestamppb.New(secret.Created),
                        Updated: timestamppb.New(secret.Updated),
                })
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

// EditSecret - метод для добавления секрета
func (s *Keeper) EditSecret(ctx context.Context, request *pb.EditSecretRequest) (*pb.EditSecretResponse, error) <span class="cov8" title="1">{
        uid, err := usercontext.GetUserId(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Unauthenticated, err.Error())
        }</span>
        <span class="cov8" title="1">sid, err := uuid.Parse(request.GetMeta().GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>
        <span class="cov8" title="1">m := &amp;models.SecretData{
                ID:      sid,
                UserID:  uid,
                Name:    request.GetMeta().GetName(),
                Type:    request.GetMeta().GetType(),
                Content: request.GetContent(),
        }
        secret, err := s.secrets.Edit(ctx, m)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, storage.ErrNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, err.Error())
                }</span>
                <span class="cov8" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
        }
        <span class="cov8" title="1">return &amp;pb.EditSecretResponse{Meta: &amp;pb.SecretMetadata{
                Id:      secret.ID.String(),
                Name:    m.Name,
                Type:    m.Type,
                Created: timestamppb.New(secret.Created),
                Updated: timestamppb.New(secret.Updated)}}, nil</span>
}

func (s *Keeper) RegisterService(r grpc.ServiceRegistrar) <span class="cov0" title="0">{
        pb.RegisterKeeperServer(r, s)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package services

import (
        "context"
        "go-pass-keeper/internal/models"
        "go-pass-keeper/internal/storage"
        "go-pass-keeper/pkg/crypto"
        pb "go-pass-keeper/pkg/proto"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// tokenBuilder интефрейс для работы с токеном
type tokenBuilder interface {
        // BuildJWT - создание токена с ID пользователя
        BuildJWT(userID string) (string, error)
}

// User - модель сервиса пользователей
type User struct {
        pb.UnimplementedUserServer

        users storage.User
        token tokenBuilder
}

// NewUser - метод создания сервиса работы с пользователями
func NewUser(u storage.User, th tokenBuilder) *User <span class="cov8" title="1">{
        return &amp;User{
                users: u,
                token: th,
        }
}</span>

// Register - метод обработки запроса регистрации пользователя
func (s User) Register(ctx context.Context, request *pb.RegisterRequest) (*pb.RegisterResponse, error) <span class="cov8" title="1">{

        salt, err := crypto.GenerateSalt()
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>
        <span class="cov8" title="1">uid, err := s.users.Add(ctx, &amp;models.UserData{Login: request.GetLogin(), Password: request.GetPassword(), Salt: salt})
        switch err </span>{
        case nil:<span class="cov8" title="1"></span>
        case storage.ErrAlreadyExists:<span class="cov8" title="1">
                return nil, status.Error(codes.InvalidArgument, err.Error())</span>
        default:<span class="cov8" title="1">
                return nil, status.Error(codes.Internal, err.Error())</span>
        }
        <span class="cov8" title="1">t, err := s.token.BuildJWT(uid.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;pb.RegisterResponse{Token: t, Salt: salt}, nil</span>
}

// Login - метод обработки запроса автооризации пользователя
func (s User) Login(ctx context.Context, request *pb.LoginRequest) (*pb.LoginResponse, error) <span class="cov8" title="1">{
        u, err := s.users.Get(ctx, request.GetLogin(), request.GetPassword())
        switch err </span>{
        case nil:<span class="cov8" title="1"></span>
        case storage.ErrNotFound:<span class="cov8" title="1">
                return nil, status.Error(codes.Unauthenticated, err.Error())</span>
        default:<span class="cov8" title="1">
                return nil, status.Error(codes.Internal, err.Error())</span>
        }
        <span class="cov8" title="1">t, err := s.token.BuildJWT(u.ID.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>
        <span class="cov8" title="1">return &amp;pb.LoginResponse{Token: t, Salt: u.Salt}, nil</span>
}

// RegisterService - метод регистрации сервиса
func (s *User) RegisterService(r grpc.ServiceRegistrar) <span class="cov0" title="0">{
        pb.RegisterUserServer(r, s)
}</span>

// AuthFuncOverride - метод для кастомной обработки метода авторизации (использую для исключений проверки авторизации по токену)
func (s *User) AuthFuncOverride(ctx context.Context, fullMethodName string) (context.Context, error) <span class="cov0" title="0">{
        return ctx, nil
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal\storage\storage.go
//
// Generated by this command:
//
//        mockgen -source=internal\storage\storage.go -destination=internal\storage\mocks\storage_mock.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        models "go-pass-keeper/internal/models"
        reflect "reflect"

        uuid "github.com/google/uuid"
        gomock "go.uber.org/mock/gomock"
)

// MockUser is a mock of User interface.
type MockUser struct {
        ctrl     *gomock.Controller
        recorder *MockUserMockRecorder
        isgomock struct{}
}

// MockUserMockRecorder is the mock recorder for MockUser.
type MockUserMockRecorder struct {
        mock *MockUser
}

// NewMockUser creates a new mock instance.
func NewMockUser(ctrl *gomock.Controller) *MockUser <span class="cov0" title="0">{
        mock := &amp;MockUser{ctrl: ctrl}
        mock.recorder = &amp;MockUserMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUser) EXPECT() *MockUserMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Add mocks base method.
func (m *MockUser) Add(ctx context.Context, user *models.UserData) (uuid.UUID, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Add", ctx, user)
        ret0, _ := ret[0].(uuid.UUID)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Add indicates an expected call of Add.
func (mr *MockUserMockRecorder) Add(ctx, user any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockUser)(nil).Add), ctx, user)
}</span>

// Get mocks base method.
func (m *MockUser) Get(ctx context.Context, login, password string) (*models.UserData, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, login, password)
        ret0, _ := ret[0].(*models.UserData)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockUserMockRecorder) Get(ctx, login, password any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockUser)(nil).Get), ctx, login, password)
}</span>

// MockSecret is a mock of Secret interface.
type MockSecret struct {
        ctrl     *gomock.Controller
        recorder *MockSecretMockRecorder
        isgomock struct{}
}

// MockSecretMockRecorder is the mock recorder for MockSecret.
type MockSecretMockRecorder struct {
        mock *MockSecret
}

// NewMockSecret creates a new mock instance.
func NewMockSecret(ctrl *gomock.Controller) *MockSecret <span class="cov0" title="0">{
        mock := &amp;MockSecret{ctrl: ctrl}
        mock.recorder = &amp;MockSecretMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSecret) EXPECT() *MockSecretMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Add mocks base method.
func (m_2 *MockSecret) Add(ctx context.Context, m *models.SecretData) (*models.SecretData, error) <span class="cov0" title="0">{
        m_2.ctrl.T.Helper()
        ret := m_2.ctrl.Call(m_2, "Add", ctx, m)
        ret0, _ := ret[0].(*models.SecretData)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Add indicates an expected call of Add.
func (mr *MockSecretMockRecorder) Add(ctx, m any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockSecret)(nil).Add), ctx, m)
}</span>

// Delete mocks base method.
func (m *MockSecret) Delete(ctx context.Context, sid uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, sid)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockSecretMockRecorder) Delete(ctx, sid any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockSecret)(nil).Delete), ctx, sid)
}</span>

// Edit mocks base method.
func (m_2 *MockSecret) Edit(ctx context.Context, m *models.SecretData) (*models.SecretData, error) <span class="cov0" title="0">{
        m_2.ctrl.T.Helper()
        ret := m_2.ctrl.Call(m_2, "Edit", ctx, m)
        ret0, _ := ret[0].(*models.SecretData)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Edit indicates an expected call of Edit.
func (mr *MockSecretMockRecorder) Edit(ctx, m any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Edit", reflect.TypeOf((*MockSecret)(nil).Edit), ctx, m)
}</span>

// Get mocks base method.
func (m *MockSecret) Get(ctx context.Context, sid uuid.UUID) (*models.SecretData, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, sid)
        ret0, _ := ret[0].(*models.SecretData)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockSecretMockRecorder) Get(ctx, sid any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockSecret)(nil).Get), ctx, sid)
}</span>

// List mocks base method.
func (m *MockSecret) List(ctx context.Context, uid uuid.UUID) ([]*models.SecretData, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", ctx, uid)
        ret0, _ := ret[0].([]*models.SecretData)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockSecretMockRecorder) List(ctx, uid any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockSecret)(nil).List), ctx, uid)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package storage

import (
        "context"
        "database/sql"
        "embed"
        "fmt"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/pressly/goose/v3"
)

type Database struct {
        Pool   *pgxpool.Pool
        config *pgx.ConnConfig
        dsn    string
}

const (
        CheckExist     = `SELECT EXISTS(SELECT 1 FROM pg_database WHERE datname =$1)`
        CreateDatabase = `CREATE DATABASE %s`
)

// Создание хранилища
func NewDatabase(dsn string) (*Database, error) <span class="cov0" title="0">{
        pool, err := pgxpool.New(context.Background(), dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to create connection pool: %w", err)
        }</span>
        <span class="cov0" title="0">cfg, err := pgxpool.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse database config: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;Database{Pool: pool, config: cfg.ConnConfig, dsn: dsn}, nil</span>
}

// Инициализация хранилища (создание БД, миграция)
func (s *Database) Initialize() error <span class="cov0" title="0">{

        if err := s.CreateDatabase(context.Background()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error create database: %w", err)
        }</span>
        <span class="cov0" title="0">if err := Migration(s.dsn); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error migrate database: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

//go:embed migrations/*.sql
var embedMigrations embed.FS

func Migration(DatabaseDSN string) error <span class="cov0" title="0">{

        db, err := sql.Open("pgx", DatabaseDSN)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open db error: %w ", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()
        // используется для внутренней файловой системы (загруженные ресурсы)
        goose.SetBaseFS(embedMigrations)

        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("goose set dialect error: %w ", err)
        }</span>

        <span class="cov0" title="0">if err := goose.Up(db, "migrations"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("goose run migrations error:  %w ", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Database) Close() error <span class="cov0" title="0">{
        s.Pool.Close()
        return nil
}</span>

func (s *Database) CreateDatabase(ctx context.Context) error <span class="cov0" title="0">{
        // goose не умеет создавать БД
        conn, err := pgx.ConnectConfig(ctx, s.config)
        if err != nil </span><span class="cov0" title="0">{
                // если не получилось соединиться с БД из строки подключения
                // пробуем использовать дефолтную БД
                cfg := s.config.Copy()
                cfg.Database = `postgres`
                conn, err = pgx.ConnectConfig(ctx, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to connect database: %w", err)
                }</span>
                <span class="cov0" title="0">var exist bool
                err = conn.QueryRow(ctx, CheckExist, s.config.Database).Scan(&amp;exist)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check database exists: %w", err)
                }</span>
                <span class="cov0" title="0">if !exist </span><span class="cov0" title="0">{
                        _, err = conn.Exec(ctx, fmt.Sprintf(CreateDatabase, s.config.Database))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create database: %w", err)
                        }</span>
                }
        }
        <span class="cov0" title="0">defer conn.Close(ctx)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package storage

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "go-pass-keeper/internal/models"
        "time"

        "github.com/google/uuid"
        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5/pgconn"
)

// UserStorage - хранилище секретов пользователей
type SecretStorage struct {
        db *Database // указатель на базу данных
}

// NewUserStorage - метод создаёт подключение к таблице пользователей
func NewSecretStorage(db *Database) *SecretStorage <span class="cov0" title="0">{
        return &amp;SecretStorage{db: db}
}</span>

// Add - метод добавляет секрет пользователя в хранилище
func (s *SecretStorage) Add(ctx context.Context, secret *models.SecretData) (*models.SecretData, error) <span class="cov0" title="0">{
        const query = `
                INSERT INTO secrets (user_id, type_secret, name, content)
                VALUES ($1, $2, $3, $4)
                RETURNING id, created_at, updated_at
`
        m := &amp;models.SecretData{}
        err := s.db.Pool.QueryRow(ctx, query, secret.UserID, secret.Type, secret.Name, secret.Content).Scan(&amp;m.ID, &amp;m.Created, &amp;m.Updated)
        if err != nil </span><span class="cov0" title="0">{
                var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) &amp;&amp; pgerrcode.IsIntegrityConstraintViolation(string(pgErr.Code)) </span><span class="cov0" title="0">{
                        return m, ErrAlreadyExists
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to add secret: %w", err)</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// Get - получение записи с секретом (возвращает модель секрета)
func (s *SecretStorage) Get(ctx context.Context, sid uuid.UUID) (*models.SecretData, error) <span class="cov0" title="0">{
        const query = `
                SELECT id, type_secret, name, content, created_at, updated_at FROM secrets
                WHERE id = $1;
`
        m := &amp;models.SecretData{}
        err := s.db.Pool.QueryRow(ctx, query, sid.String()).Scan(&amp;m.ID, &amp;m.Type, &amp;m.Name, &amp;m.Content, &amp;m.Created, &amp;m.Updated)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get secret: %w", err)</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

// Delete - метод удаляет запись секрета из таблицы
func (s *SecretStorage) Delete(ctx context.Context, sid uuid.UUID) error <span class="cov0" title="0">{
        const query = `
                DELETE FROM secrets
                WHERE id = $1;
`
        res, err := s.db.Pool.Exec(ctx, query, sid)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete secret: %w", err)
        }</span>
        <span class="cov0" title="0">if res.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// List - метод возвращает список секретов пользователя
func (s *SecretStorage) List(ctx context.Context, uid uuid.UUID) ([]*models.SecretData, error) <span class="cov0" title="0">{
        const SQL = `
                SELECT id, user_id, type_secret, name, created_at, updated_at FROM secrets
                WHERE user_id = $1 ORDER BY name
`
        rows, err := s.db.Pool.Query(ctx, SQL, uid)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get secrets: %w", err)</span>
        }
        <span class="cov0" title="0">res := make([]*models.SecretData, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id          uuid.UUID
                        user_id     uuid.UUID
                        type_secret string
                        name        string
                        created     time.Time
                        updated     time.Time
                )
                err := rows.Scan(
                        &amp;id,
                        &amp;user_id,
                        &amp;type_secret,
                        &amp;name,
                        &amp;created,
                        &amp;updated,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return res, fmt.Errorf("failed scan secret data: %w", err)
                }</span>
                <span class="cov0" title="0">res = append(res, &amp;models.SecretData{
                        ID:      id,
                        UserID:  user_id,
                        Name:    name,
                        Type:    type_secret,
                        Created: created,
                        Updated: updated})</span>
        }

        <span class="cov0" title="0">return res, nil</span>
}

// Edit - метод изменяет запись секрета (возвращает модель секрета)
func (s *SecretStorage) Edit(ctx context.Context, secret *models.SecretData) (*models.SecretData, error) <span class="cov0" title="0">{
        const query = `
                UPDATE secrets 
                SET name = $2, content = $3, updated_at = CURRENT_TIMESTAMP
                WHERE id = $1
                RETURNING id, user_id, type_secret, name, content, created_at, updated_at;
`
        m := &amp;models.SecretData{}
        err := s.db.Pool.QueryRow(ctx, query, secret.ID, secret.Name, secret.Content).
                Scan(&amp;m.ID, &amp;m.UserID, &amp;m.Type, &amp;m.Name, &amp;m.Content, &amp;m.Created, &amp;m.Updated)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to edit secret: %w", err)</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package storage

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "go-pass-keeper/internal/models"

        "github.com/google/uuid"
        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5/pgconn"
)

// UserStorage - хранилище пользователей
type UserStorage struct {
        db *Database // указатель на базу данных
}

// NewUserStorage - метод создаёт подключение к таблице пользователей
func NewUserStorage(db *Database) *UserStorage <span class="cov0" title="0">{
        return &amp;UserStorage{db: db}
}</span>

// Add - метод добавляет пользователя в хранилище
func (s *UserStorage) Add(ctx context.Context, user *models.UserData) (uuid.UUID, error) <span class="cov0" title="0">{
        const query = `
                INSERT INTO users (login, password, salt)
                VALUES ($1, crypt($2, gen_salt('bf')), $3)
                RETURNING id
`
        var uid uuid.UUID
        err := s.db.Pool.QueryRow(ctx, query, user.Login, user.Password, user.Salt).Scan(&amp;uid)
        if err != nil </span><span class="cov0" title="0">{
                var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) &amp;&amp; pgerrcode.IsIntegrityConstraintViolation(string(pgErr.Code)) </span><span class="cov0" title="0">{
                        return uuid.Nil, ErrAlreadyExists
                }</span>
                <span class="cov0" title="0">return uuid.Nil, fmt.Errorf("failed to add user: %w", err)</span>
        }

        <span class="cov0" title="0">return uid, nil</span>
}

// Get - метод извлекает пользователя из хранилища с использованием логина и пароля
func (s *UserStorage) Get(ctx context.Context, login string, password string) (*models.UserData, error) <span class="cov0" title="0">{
        const query = `
                SELECT id, login, salt FROM users
                WHERE login = $1 AND password = crypt($2, password);
`
        user := &amp;models.UserData{}

        err := s.db.Pool.QueryRow(ctx, query, login, password).Scan(&amp;user.ID, &amp;user.Login, &amp;user.Salt)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package token

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt"
)

// JWT - структура для создания JWT токены
type JWT struct {
        secretKey []byte
}

func NewJWT(secretKey string) (*JWT, error) <span class="cov8" title="1">{
        if len(secretKey) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("empty secret key")
        }</span>
        <span class="cov8" title="1">return &amp;JWT{
                secretKey: []byte(secretKey),
        }, nil</span>
}

// JWTClaims описание записей в токене JWT
type JWTClaims struct {
        jwt.StandardClaims
}

// JWTExpire - время жизни токена
const JWTExpire = time.Hour * 3

// BuildJWT - метод для формирования JWT токена с добавлением UUID пользователя
func (j *JWT) BuildJWT(userID string) (string, error) <span class="cov8" title="1">{
        now := time.Now()
        exp := now.Add(JWTExpire)
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, JWTClaims{
                StandardClaims: jwt.StandardClaims{
                        Id:        userID,
                        ExpiresAt: exp.Unix(),
                        IssuedAt:  now.Unix(),
                        NotBefore: now.Unix(),
                },
        })

        tokenString, err := token.SignedString(j.secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

// ParseJWT - метод разбора JWT токена с проверкой секрета и возвратом кастомных записей
func (j *JWT) ParseJWT(token string) (*JWTClaims, error) <span class="cov8" title="1">{
        claims := &amp;JWTClaims{}

        jwtToken, err := jwt.ParseWithClaims(token, claims,
                func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov8" title="1">return j.secretKey, nil</span>
                })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !jwtToken.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token is not valid")
        }</span>
        <span class="cov8" title="1">return claims, nil</span>
}

// DecodeUserId - метод извлечения ID пользователя из токена
func (j *JWT) DecodeUserId(token string) (string, error) <span class="cov8" title="1">{
        claims, err := j.ParseJWT(token)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return claims.StandardClaims.Id, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package messages

import (
        "fmt"
        "go-pass-keeper/internal/models"

        tea "github.com/charmbracelet/bubbletea"
)

// Тип переменной состояние перехода
type MsgActionType int

const (
        AddSecretType MsgActionType = iota
        EditSecretType
)

// EncryptConverter - интерфейс для расшифровки сообщений
type EncryptConverter interface {
        ToModel([]byte) (*models.SecretInfo, []byte, error)
}

// SecretPassword - модель с данными логин/пароль
type SecretPassword struct {
        Name     string
        Type     string
        Login    string
        Password string
}

// AddSecretPasswordMsg - сообщение для добавления данными логин/пароль
type AddSecretPasswordMsg struct {
        Data SecretPassword
}

// ToModel - метод формирует информацию о секрете и шифрованный контент
func (msg *AddSecretPasswordMsg) ToModel(key []byte) (*models.SecretInfo, []byte, error) <span class="cov0" title="0">{

        secret := models.NewSecretPassword(msg.Data.Login, msg.Data.Password)
        data, err := secret.Encrypt(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to encrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;models.SecretInfo{Name: msg.Data.Name, Type: msg.Data.Type}, data, nil</span>
}

// EditSecretPasswordMsg - сообщение для редактирования секрета (логин/пароль)
type EditSecretPasswordMsg struct {
        ID   string
        Data SecretPassword
}

// ToModel - метод формирует информацию о секрете и шифрованный контент
func (msg *EditSecretPasswordMsg) ToModel(key []byte) (*models.SecretInfo, []byte, error) <span class="cov0" title="0">{

        secret := models.NewSecretPassword(msg.Data.Login, msg.Data.Password)
        data, err := secret.Encrypt(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to encrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;models.SecretInfo{ID: msg.ID, Name: msg.Data.Name, Type: msg.Data.Type}, data, nil</span>
}

// GetSecretPasswordMsg - сообщение для получения данных логин/пароль
type GetSecretPasswordMsg struct {
        ID   string
        Data SecretPassword
}

// FromModel - метод формирует информацию о секрете, расшифрованный контент и формирует сообщение
func (msg *GetSecretPasswordMsg) FromModel(key []byte, info *models.SecretInfo, content []byte) error <span class="cov0" title="0">{
        secret := &amp;models.SecretPassword{}
        err := secret.Decrypt(key, content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">msg.ID = info.ID
        msg.Data = SecretPassword{Name: info.Name, Type: info.Type, Login: secret.Login, Password: secret.Password}
        return nil</span>
}

// SecretCard - модель с данными карты
type SecretCard struct {
        Name   string
        Type   string
        Number string
        Date   string
        CVV    string
        Owner  string
}

// AddSecretCardMsg - сообщение для добавления с данными карты
type AddSecretCardMsg struct {
        Data SecretCard
}

// ToModel - метод формирует информацию о секрете и шифрованный контент
func (msg *AddSecretCardMsg) ToModel(key []byte) (*models.SecretInfo, []byte, error) <span class="cov0" title="0">{

        secret := models.NewSecretCard(msg.Data.Number, msg.Data.Date, msg.Data.CVV, msg.Data.Owner)
        data, err := secret.Encrypt(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to encrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;models.SecretInfo{Name: msg.Data.Name, Type: msg.Data.Type}, data, nil</span>
}

// EditSecretCardMsg - сообщение для редактирования данных карты
type EditSecretCardMsg struct {
        ID   string
        Data SecretCard
}

// ToModel - метод формирует информацию о секрете и шифрованный контент
func (msg *EditSecretCardMsg) ToModel(key []byte) (*models.SecretInfo, []byte, error) <span class="cov0" title="0">{

        secret := models.NewSecretCard(msg.Data.Number, msg.Data.Date, msg.Data.CVV, msg.Data.Owner)
        data, err := secret.Encrypt(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to encrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;models.SecretInfo{ID: msg.ID, Name: msg.Data.Name, Type: msg.Data.Type}, data, nil</span>
}

// GetSecretCardMsg - сообщение для получения данных карты
type GetSecretCardMsg struct {
        ID   string
        Data SecretCard
}

// FromModel - метод формирует информацию о секрете, расшифрованный контент и формирует сообщение
func (msg *GetSecretCardMsg) FromModel(key []byte, info *models.SecretInfo, content []byte) error <span class="cov0" title="0">{
        secret := &amp;models.SecretCard{}
        err := secret.Decrypt(key, content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">msg.ID = info.ID
        msg.Data = SecretCard{Name: info.Name, Type: info.Type, Number: secret.Number, CVV: secret.CVV, Date: secret.Date, Owner: secret.Owner}
        return nil</span>
}

// SecretText - модель с текстовыми данными
type SecretText struct {
        Name string
        Type string
        Text string
}

// AddSecretTextMsg - сообщение для добавления секрета с текстовыми данными
type AddSecretTextMsg struct {
        Data SecretText
}

// ToModel - метод формирует информацию о секрете и шифрованный контент
func (msg *AddSecretTextMsg) ToModel(key []byte) (*models.SecretInfo, []byte, error) <span class="cov0" title="0">{

        secret := models.NewSecretText(msg.Data.Text)
        data, err := secret.Encrypt(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to encrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;models.SecretInfo{Name: msg.Data.Name, Type: msg.Data.Type}, data, nil</span>
}

// EditSecretTextMsg - сообщение для изменения секрета с текстовыми данными
type EditSecretTextMsg struct {
        ID   string
        Data SecretText
}

// ToModel - метод формирует информацию о секрете и шифрованный контент
func (msg *EditSecretTextMsg) ToModel(key []byte) (*models.SecretInfo, []byte, error) <span class="cov0" title="0">{

        secret := models.NewSecretText(msg.Data.Text)
        data, err := secret.Encrypt(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to encrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;models.SecretInfo{ID: msg.ID, Name: msg.Data.Name, Type: msg.Data.Type}, data, nil</span>
}

// GetSecretTextMsg - сообщение для получения секрета с  текстовыми данными
type GetSecretTextMsg struct {
        ID   string
        Data SecretText
}

// FromModel - метод формирует информацию о секрете, расшифрованный контент и формирует сообщение
func (msg *GetSecretTextMsg) FromModel(key []byte, info *models.SecretInfo, content []byte) error <span class="cov0" title="0">{
        secret := &amp;models.SecretText{}
        err := secret.Decrypt(key, content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">msg.ID = info.ID
        msg.Data = SecretText{Name: info.Name, Type: info.Type, Text: secret.Text}
        return nil</span>
}

// SecretBinary - модель с бинарными данными
type SecretBinary struct {
        Name string
        Type string
        Blob []byte
}

// AddSecretBinaryMsg - сообщение для добавления секрета с бинарными данными
type AddSecretBinaryMsg struct {
        Data SecretBinary
}

// ToModel - метод формирует информацию о секрете и шифрованный контент
func (msg *AddSecretBinaryMsg) ToModel(key []byte) (*models.SecretInfo, []byte, error) <span class="cov0" title="0">{

        secret := models.NewSecretBinary(msg.Data.Blob)
        data, err := secret.Encrypt(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to encrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;models.SecretInfo{Name: msg.Data.Name, Type: msg.Data.Type}, data, nil</span>
}

// EditSecretBinaryMsg - сообщение для изменения секрета с бинарными данными
type EditSecretBinaryMsg struct {
        ID   string
        Data SecretBinary
}

// ToModel - метод формирует информацию о секрете и шифрованный контент
func (msg *EditSecretBinaryMsg) ToModel(key []byte) (*models.SecretInfo, []byte, error) <span class="cov0" title="0">{

        secret := models.NewSecretBinary(msg.Data.Blob)
        data, err := secret.Encrypt(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to encrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;models.SecretInfo{ID: msg.ID, Name: msg.Data.Name, Type: msg.Data.Type}, data, nil</span>
}

// GetSecretBinaryMsg - сообщение для получения секрета с бинарными данными
type GetSecretBinaryMsg struct {
        ID   string
        Data SecretBinary
}

// FromModel - метод формирует информацию о секрете, расшифрованный контент и формирует сообщение
func (msg *GetSecretBinaryMsg) FromModel(key []byte, info *models.SecretInfo, content []byte) error <span class="cov0" title="0">{
        secret := &amp;models.SecretBinary{}
        err := secret.Decrypt(key, content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">msg.ID = info.ID
        msg.Data = SecretBinary{Name: info.Name, Type: info.Type, Blob: secret.Blob}
        return nil</span>
}

// ToMessage - метод формирует сообщение на основе информации о секрете
func ToMessage(key []byte, info *models.SecretInfo, content []byte) tea.Msg <span class="cov0" title="0">{
        switch info.Type </span>{
        case models.SecretPasswordType:<span class="cov0" title="0">
                msg := GetSecretPasswordMsg{ID: info.ID}
                err := msg.FromModel(key, info, content)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrorMsg(fmt.Sprintf("Ошибка разбора сообщения: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">return msg</span>
        case models.SecretCardType:<span class="cov0" title="0">
                msg := GetSecretCardMsg{ID: info.ID}
                err := msg.FromModel(key, info, content)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrorMsg(fmt.Sprintf("Ошибка разбора сообщения: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">return msg</span>
        case models.SecretTextType:<span class="cov0" title="0">
                msg := GetSecretTextMsg{ID: info.ID}
                err := msg.FromModel(key, info, content)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrorMsg(fmt.Sprintf("Ошибка разбора сообщения: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">return msg</span>
        case models.SecretBinaryType:<span class="cov0" title="0">
                msg := GetSecretBinaryMsg{ID: info.ID}
                err := msg.FromModel(key, info, content)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrorMsg(fmt.Sprintf("Ошибка разбора сообщения: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">return msg</span>
        default:<span class="cov0" title="0">
                return ErrorMsg("Неизвестный тип сообщения")</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package models

import (
        "go-pass-keeper/internal/tui/messages"
        "go-pass-keeper/internal/tui/styles"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// Состояния модели
const (
        SecretTypeSelectState = iota
        LoginPasswordState
        TextState
        FileState
        BankCardState
)

// SecretAddModel - модель выбора создаваемого секрета
type SecretAddModel struct {
        state       int
        windowSize  tea.WindowSizeMsg
        focusedBtn  int
        secretTypes []string

        loginModel LoginSecretModel
        textModel  TextSecretModel
        fileModel  FileSecretModel
        cardModel  BankCardSecretModel
}

// NewViewerModel - метод создания выбора создаваемого секрета
func NewSecretAddModel() SecretAddModel <span class="cov0" title="0">{
        return SecretAddModel{
                state:       SecretTypeSelectState,
                secretTypes: []string{"🔐 Логин/Пароль", "📝 Текст", "📁 Файл", "💳 Банковская карта"},
                focusedBtn:  0,
                loginModel:  NewLoginSecretModel(),
                textModel:   NewTextSecretModel(),
                fileModel:   NewFileSecretModel(),
                cardModel:   NewBankCardSecretModel(),
        }
}</span>

// Init - метод инициализации текущего окна
func (m SecretAddModel) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.Batch(
                m.loginModel.Init(),
                m.textModel.Init(),
                m.fileModel.Init(),
                m.cardModel.Init(),
        )
}</span>

// Update - метод обновления текущего окна
func (m SecretAddModel) Update(msg tea.Msg) (SecretAddModel, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                return m.updateWindowsSize(msg)</span>

        case messages.SecretAddCancelMsg:<span class="cov0" title="0">
                m.state = SecretTypeSelectState
                return m, nil</span>
        case messages.GetSecretPasswordMsg:<span class="cov0" title="0">
                m.state = LoginPasswordState</span>
        case messages.GetSecretCardMsg:<span class="cov0" title="0">
                m.state = BankCardState</span>
        case messages.GetSecretTextMsg:<span class="cov0" title="0">
                m.state = TextState</span>
        case messages.GetSecretBinaryMsg:<span class="cov0" title="0">
                m.state = FileState</span>
        }

        <span class="cov0" title="0">switch m.state </span>{
        case SecretTypeSelectState:<span class="cov0" title="0">
                return m.updateTypeSelect(msg)</span>
        case LoginPasswordState:<span class="cov0" title="0">
                return m.updateLoginPassword(msg)</span>
        case TextState:<span class="cov0" title="0">
                return m.updateText(msg)</span>
        case FileState:<span class="cov0" title="0">
                return m.updateFile(msg)</span>
        case BankCardState:<span class="cov0" title="0">
                return m.updateBankCard(msg)</span>
        default:<span class="cov0" title="0">
                return m, nil</span>
        }
}

// updateWindowsSize - метод обновления размеров окон
func (m SecretAddModel) updateWindowsSize(msg tea.WindowSizeMsg) (SecretAddModel, tea.Cmd) <span class="cov0" title="0">{
        m.windowSize = msg

        // Передаем размеры окна всем дочерним моделям
        loginModel, loginModelCmd := m.loginModel.Update(msg)
        m.loginModel = loginModel

        fileModel, fileModelCmd := m.fileModel.Update(msg)
        m.fileModel = fileModel

        textModel, textModelCmd := m.textModel.Update(msg)
        m.textModel = textModel

        cardModel, cardModelCmd := m.cardModel.Update(msg)
        m.cardModel = cardModel

        return m, tea.Batch(loginModelCmd, fileModelCmd, textModelCmd, cardModelCmd)
}</span>

// updateTypeSelect - метод обработки выбора типа
func (m SecretAddModel) updateTypeSelect(msg tea.Msg) (SecretAddModel, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.windowSize = msg
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "up", "k":<span class="cov0" title="0">
                        if m.focusedBtn &gt; 0 </span><span class="cov0" title="0">{
                                m.focusedBtn--
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "down", "j":<span class="cov0" title="0">
                        if m.focusedBtn &lt; len(m.secretTypes)-1 </span><span class="cov0" title="0">{
                                m.focusedBtn++
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "enter":<span class="cov0" title="0">
                        switch m.focusedBtn </span>{
                        case 0:<span class="cov0" title="0"> // Логин/Пароль
                                m.state = LoginPasswordState
                                return m, nil</span>
                        case 1:<span class="cov0" title="0"> // Текст
                                m.state = TextState
                                return m, nil</span>
                        case 2:<span class="cov0" title="0"> // Файл
                                m.state = FileState
                                return m, nil</span>
                        case 3:<span class="cov0" title="0"> // Банковская карта
                                m.state = BankCardState
                                return m, nil</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "esc":<span class="cov0" title="0">
                        return m, func() tea.Msg </span><span class="cov0" title="0">{
                                return messages.SecretAddCancelMsg{}
                        }</span>
                }
        }
        <span class="cov0" title="0">return m, nil</span>
}

// updateLoginPassword - метод обновления окна секрета (пароль/логин)
func (m SecretAddModel) updateLoginPassword(msg tea.Msg) (SecretAddModel, tea.Cmd) <span class="cov0" title="0">{
        updatedModel, cmd := m.loginModel.Update(msg)
        m.loginModel = updatedModel
        return m, cmd
}</span>

// updateText - метод обновления окна секрета (текст)
func (m SecretAddModel) updateText(msg tea.Msg) (SecretAddModel, tea.Cmd) <span class="cov0" title="0">{
        updatedModel, cmd := m.textModel.Update(msg)
        m.textModel = updatedModel
        return m, cmd
}</span>

// updateFile - метод обновления окна секрета (файл)
func (m SecretAddModel) updateFile(msg tea.Msg) (SecretAddModel, tea.Cmd) <span class="cov0" title="0">{
        updatedModel, cmd := m.fileModel.Update(msg)
        m.fileModel = updatedModel
        return m, cmd
}</span>

// updateBankCard - метод обновления окна секрета (банковская карта)
func (m SecretAddModel) updateBankCard(msg tea.Msg) (SecretAddModel, tea.Cmd) <span class="cov0" title="0">{
        updatedModel, cmd := m.cardModel.Update(msg)
        m.cardModel = updatedModel
        return m, cmd
}</span>

// View - метод отрисовки текущего состояния
func (m SecretAddModel) View() string <span class="cov0" title="0">{
        switch m.state </span>{
        case SecretTypeSelectState:<span class="cov0" title="0">
                return m.renderTypeSelectView()</span>
        case LoginPasswordState:<span class="cov0" title="0">
                return m.loginModel.View()</span>
        case TextState:<span class="cov0" title="0">
                return m.textModel.View()</span>
        case FileState:<span class="cov0" title="0">
                return m.fileModel.View()</span>
        case BankCardState:<span class="cov0" title="0">
                return m.cardModel.View()</span>
        default:<span class="cov0" title="0">
                return "Неизвестное состояние"</span>
        }
}

// renderTypeSelectView - метод для отрисовки кнопок в окне выбора типа создаваемого секрета
func (m SecretAddModel) renderTypeSelectView() string <span class="cov0" title="0">{
        // Создаем кнопки выбора типа
        buttons := make([]string, len(m.secretTypes))
        for i, secretType := range m.secretTypes </span><span class="cov0" title="0">{
                if i == m.focusedBtn </span><span class="cov0" title="0">{
                        buttons[i] = styles.ActiveButtonStyle.
                                Width(20).
                                Height(3).
                                Render(secretType)
                }</span> else<span class="cov0" title="0"> {
                        buttons[i] = styles.ButtonStyle.
                                Width(20).
                                Height(3).
                                Render(secretType)
                }</span>
        }

        <span class="cov0" title="0">content := lipgloss.JoinVertical(
                lipgloss.Center,
                styles.TitleStyle.
                        Width(40).
                        Render("➕ Выберите тип секрета"),

                lipgloss.NewStyle().Height(2).Render(""),

                lipgloss.JoinVertical(lipgloss.Center, buttons...),

                lipgloss.NewStyle().Height(2).Render(""),

                lipgloss.NewStyle().
                        Foreground(styles.TextSecondary).
                        Italic(true).
                        Render("↑/↓: выбор типа • Enter: подтвердить • ESC: отмена"),
        )

        return styles.ContainerStyle.
                Width(m.windowSize.Width).
                Height(m.windowSize.Height).
                Render(
                        lipgloss.Place(
                                m.windowSize.Width, m.windowSize.Height,
                                lipgloss.Center, lipgloss.Center,
                                content,
                                lipgloss.WithWhitespaceChars(" "),
                                lipgloss.WithWhitespaceForeground(styles.BackgroundColor),
                        ),
                )</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package models

import (
        "go-pass-keeper/internal/grpcclient/config"
        "go-pass-keeper/internal/tui/messages"
        "go-pass-keeper/internal/tui/styles"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// Тип переменной состояние перехода
type AppState int

// Состояние переходов
const (
        MainState AppState = iota
        LoginState
        RegisterState
        SecretState
        SettingsState
)

// Кнопки на главном окне
const (
        LoginButton = iota
        RegisterButton
        SecretButton
        SettingsButton
)

// AppModel - модель главного окна
type AppModel struct {
        state      AppState
        auth       AuthModel
        register   RegisterModel
        secrets    ViewerModel
        settings   SettingsModel
        windowSize tea.WindowSizeMsg
        focused    int
        username   string
        token      string
        config     *config.Config
        version    string
}

// NewAppModel - метод для создания главного окна
func NewAppModel(config *config.Config, version string) AppModel <span class="cov0" title="0">{

        connection := config.Load()
        return AppModel{
                state:    MainState,
                auth:     NewAuthModel(connection),
                register: NewRegisterModel(connection),
                secrets:  NewViewerModel(connection),
                settings: NewSettingsModel(connection),
                focused:  0,
                username: "",
                token:    "",
                config:   config,
                version:  version,
        }
}</span>

// Init - метод инициализации окна
func (m AppModel) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

// Update - метод для обновления окна по внешним сообщениям
func (m AppModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                return m.updateWindowsSize(msg)</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.Type </span>{
                case tea.KeyCtrlC:<span class="cov0" title="0">
                        return m, tea.Quit</span>
                case tea.KeyEsc:<span class="cov0" title="0">
                        // Обработка ESC в зависимости от текущего состояния
                        switch m.state </span>{
                        case LoginState, RegisterState:<span class="cov0" title="0">
                                // Возврат на главный экран
                                m.state = MainState
                                m.auth.err = ""
                                m.register.err = ""
                                return m, nil</span>
                        case SettingsState:<span class="cov0" title="0">
                                // Выход из главного экрана или просмотра
                                m.state = MainState
                                return m, nil</span>
                        case MainState:<span class="cov0" title="0">
                                // Выход из приложения
                                return m, tea.Quit</span>
                        }
                }

        case messages.AuthSuccessMsg:<span class="cov0" title="0">
                m.state = MainState
                m.username = msg.Username
                m.token = msg.Token
                return m.handleSecretUpdate(msg)</span>

        case messages.ErrorMsg:<span class="cov0" title="0">
                switch m.state </span>{
                case LoginState:<span class="cov0" title="0">
                        m.auth.err = msg</span>
                case RegisterState:<span class="cov0" title="0">
                        m.register.err = msg</span>
                }
                <span class="cov0" title="0">return m, nil</span>

        case messages.GotoMainPageMsg:<span class="cov0" title="0">
                m.state = MainState
                return m, nil</span>

        case messages.ConfigUpdatedMsg:<span class="cov0" title="0">
                m.config.Save(&amp;msg.Connection)
                m.state = MainState
                return m, nil</span>
        }

        // Обновление текущего состояния
        <span class="cov0" title="0">switch m.state </span>{
        case MainState:<span class="cov0" title="0">
                return m.handleMainUpdate(msg)</span>
        case LoginState:<span class="cov0" title="0">
                return m.handleLoginUpdate(msg)</span>
        case RegisterState:<span class="cov0" title="0">
                return m.handleRegisterUpdate(msg)</span>
        case SecretState:<span class="cov0" title="0">
                return m.handleSecretUpdate(msg)</span>
        case SettingsState:<span class="cov0" title="0">
                return m.handleSettingsUpdate(msg)</span>
        }

        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
}

// View - метод для отрисовки окна, в зависимости от текущего состояния
func (m AppModel) View() string <span class="cov0" title="0">{
        switch m.state </span>{
        case MainState:<span class="cov0" title="0">
                return m.renderMainView()</span>
        case LoginState:<span class="cov0" title="0">
                return m.auth.View()</span>
        case RegisterState:<span class="cov0" title="0">
                return m.register.View()</span>
        case SecretState:<span class="cov0" title="0">
                return m.secrets.View()</span>
        case SettingsState:<span class="cov0" title="0">
                return m.settings.View()</span>
        default:<span class="cov0" title="0">
                return "Неизвестное состояние"</span>
        }
}

// updateWindowsSize - метод обновления размеров окон
func (m AppModel) updateWindowsSize(msg tea.WindowSizeMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        m.windowSize = msg

        // Передаем размеры окна всем дочерним моделям
        updatedLogin, loginCmd := m.auth.Update(msg)
        m.auth = updatedLogin

        updatedRegister, registerCmd := m.register.Update(msg)
        m.register = updatedRegister

        updatedViewer, secretsCmd := m.secrets.Update(msg)
        m.secrets = updatedViewer

        updatedSettings, settingsCmd := m.settings.Update(msg)
        m.settings = updatedSettings

        return m, tea.Batch(loginCmd, registerCmd, secretsCmd, settingsCmd)
}</span>

// renderMainView - метод отрисовки основного окна
func (m AppModel) renderMainView() string <span class="cov0" title="0">{
        // Статус пользователя
        userStatus := m.getUserStatus()

        content := lipgloss.JoinVertical(
                lipgloss.Center,
                styles.TitleStyle.
                        Width(50).
                        Render("✨ Добро пожаловать!"),

                userStatus,
                lipgloss.NewStyle().Height(1).Render(""),

                styles.SubtitleStyle.
                        Width(50).
                        Render("Выберите действие для продолжения работы"),

                lipgloss.NewStyle().Height(1).Render(""),
                lipgloss.JoinVertical(lipgloss.Center,
                        m.renderLoginButton(),
                        m.renderRegisterButton(),
                        m.renderSecretButton(),
                        m.renderSettingsButton(),
                ),

                lipgloss.NewStyle().Height(1).Render(""),

                styles.HelpStyle.
                        Render("↑/↓: выбор • Enter: подтвердить • S: настройки • ESC: выход"),

                // Добавляем версию внизу
                lipgloss.NewStyle().Height(1).Render(""),
                lipgloss.NewStyle().
                        Foreground(styles.AccentColor).
                        Border(lipgloss.NormalBorder()).
                        Render(m.version),
        )

        return styles.ContainerStyle.
                Width(m.windowSize.Width).
                Height(m.windowSize.Height).
                Render(
                        lipgloss.Place(
                                m.windowSize.Width, m.windowSize.Height,
                                lipgloss.Center, lipgloss.Center,
                                content,
                                lipgloss.WithWhitespaceChars(" "),
                                lipgloss.WithWhitespaceForeground(styles.BackgroundColor),
                        ),
                )
}</span>

// getUserStatus - метод для формирования текущего статуса авторизации
func (m AppModel) getUserStatus() string <span class="cov0" title="0">{
        if m.isAuthorized() </span><span class="cov0" title="0">{
                return lipgloss.NewStyle().
                        Foreground(styles.SuccessColor).
                        Bold(true).
                        Padding(0, 1).
                        Render("👤 Вы вошли как: " + m.username)
        }</span>
        <span class="cov0" title="0">return lipgloss.NewStyle().
                Foreground(styles.TextSecondary).
                Italic(true).
                Render("🔒 Не авторизован")</span>
}

// renderLoginButton - метод отрисовки кнопки авторизации пользователя
func (m AppModel) renderLoginButton() string <span class="cov0" title="0">{
        text := "🔐 Вход в систему"
        if LoginButton == m.focused </span><span class="cov0" title="0">{
                return styles.ActiveButtonStyle.
                        Margin(0, 0, 1, 0).
                        Render(text)
        }</span>
        <span class="cov0" title="0">return styles.ButtonStyle.
                Margin(0, 0, 1, 0).
                Render(text)</span>
}

// renderRegisterButton - метод отрисовки кнопки регистрации пользователя
func (m AppModel) renderRegisterButton() string <span class="cov0" title="0">{
        text := "📝 Регистрация"
        if RegisterButton == m.focused </span><span class="cov0" title="0">{
                return styles.ActiveButtonStyle.
                        Margin(0, 0, 1, 0).
                        Render(text)
        }</span>
        <span class="cov0" title="0">return styles.ButtonStyle.
                Margin(0, 0, 1, 0).
                Render(text)</span>
}

// renderSecretButton - метод отрисовки кнопки просмотра секретов
func (m AppModel) renderSecretButton() string <span class="cov0" title="0">{
        text := "👁️ Просмотр"

        if SecretButton == m.focused </span><span class="cov0" title="0">{
                if m.isAuthorized() </span><span class="cov0" title="0">{
                        return styles.ActiveButtonStyle.
                                Margin(0, 0, 1, 0).
                                Render(text)
                }</span>
                <span class="cov0" title="0">return styles.DisabledActiveButtonStyle.
                        Margin(0, 0, 1, 0).
                        Render(text + " (требуется вход)")</span>
        }
        <span class="cov0" title="0">if m.isAuthorized() </span><span class="cov0" title="0">{
                return styles.ButtonStyle.
                        Margin(0, 0, 1, 0).
                        Render(text)
        }</span>
        <span class="cov0" title="0">return styles.DisabledButtonStyle.
                Margin(0, 0, 1, 0).
                Render(text + " (требуется вход)")</span>

}

// renderSettingsButton - метод отрисовки кнопки настроек клиента
func (m AppModel) renderSettingsButton() string <span class="cov0" title="0">{
        text := "⚙️ Настройки"
        if SettingsButton == m.focused </span><span class="cov0" title="0">{
                return styles.ActiveSmallButtonStyle.
                        Margin(0, 0, 1, 0).
                        Render(text)
        }</span>
        <span class="cov0" title="0">return styles.SmallButtonStyle.
                Margin(0, 0, 1, 0).
                Render(text)</span>
}

// handleMainUpdate - метод обработчик действий на кнопках основного окна
func (m AppModel) handleMainUpdate(msg tea.Msg) (AppModel, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "up", "k":<span class="cov0" title="0">
                        if m.focused &gt;= RegisterButton </span><span class="cov0" title="0">{
                                m.focused--
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                case "down", "j":<span class="cov0" title="0">
                        if m.focused &lt; SettingsButton </span><span class="cov0" title="0">{
                                m.focused++
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                case "enter":<span class="cov0" title="0">
                        switch m.focused </span>{
                        case LoginButton:<span class="cov0" title="0">
                                m.state = LoginState
                                return m, m.auth.inputs[0].Focus()</span>
                        case RegisterButton:<span class="cov0" title="0">
                                m.state = RegisterState
                                return m, m.register.inputs[0].Focus()</span>
                        case SecretButton:<span class="cov0" title="0">
                                if m.isAuthorized() </span><span class="cov0" title="0">{
                                        m.state = SecretState
                                        return m, m.secrets.Init()
                                }</span>
                                <span class="cov0" title="0">return m, nil</span>
                        case SettingsButton:<span class="cov0" title="0">
                                m.state = SettingsState
                                return m, m.settings.inputs[0].Focus()</span>
                        }
                }
        }
        <span class="cov0" title="0">return m, nil</span>
}

// handleLoginUpdate - метод обработчик действий на кнопке авторизации пользователя
func (m AppModel) handleLoginUpdate(msg tea.Msg) (AppModel, tea.Cmd) <span class="cov0" title="0">{
        updatedModel, cmd := m.auth.Update(msg)
        m.auth = updatedModel
        return m, cmd
}</span>

// handleRegisterUpdate - метод обработчик действий на кнопке регистрации пользователя
func (m AppModel) handleRegisterUpdate(msg tea.Msg) (AppModel, tea.Cmd) <span class="cov0" title="0">{
        updatedModel, cmd := m.register.Update(msg)
        m.register = updatedModel
        return m, cmd
}</span>

// handleSecretUpdate - метод обработчик действий на кнопке просмотра секретов
func (m AppModel) handleSecretUpdate(msg tea.Msg) (AppModel, tea.Cmd) <span class="cov0" title="0">{
        updatedModel, cmd := m.secrets.Update(msg)
        m.secrets = updatedModel
        return m, cmd
}</span>

// handleSettingsUpdate - метод обработчик действий на кнопке настроек клиента
func (m AppModel) handleSettingsUpdate(msg tea.Msg) (AppModel, tea.Cmd) <span class="cov0" title="0">{
        updatedModel, cmd := m.settings.Update(msg)
        m.settings = updatedModel
        return m, cmd
}</span>

// isAuthorized - метод определения наличия авторизации пользователя
func (m AppModel) isAuthorized() bool <span class="cov0" title="0">{
        return len(m.token) &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package models

import (
        "context"
        "fmt"
        "go-pass-keeper/internal/grpcclient"
        "go-pass-keeper/internal/grpcclient/settings"
        "go-pass-keeper/internal/tui/messages"
        "go-pass-keeper/internal/tui/styles"
        "time"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// AuthModel - модель окна авторизации пользователя
type AuthModel struct {
        inputs     []textinput.Model
        focused    int
        err        messages.ErrorMsg
        windowSize tea.WindowSizeMsg
        connection *settings.Settings
}

// NewAuthModel - метод для создания окна авторизации пользователя
func NewAuthModel(connection *settings.Settings) AuthModel <span class="cov0" title="0">{
        login := AuthModel{
                inputs:     make([]textinput.Model, 2),
                connection: connection,
        }

        for i := range login.inputs </span><span class="cov0" title="0">{
                t := textinput.New()
                t.Cursor.Style = styles.FocusedStyle
                t.CharLimit = 32

                switch i </span>{
                case 0:<span class="cov0" title="0">
                        t.Placeholder = "Введите имя пользователя"
                        t.PlaceholderStyle = styles.BlurredStyle
                        t.Focus()
                        t.PromptStyle = styles.FocusedStyle
                        t.TextStyle = styles.FocusedStyle</span>
                case 1:<span class="cov0" title="0">
                        t.Placeholder = "Введите пароль"
                        t.EchoMode = textinput.EchoPassword
                        t.EchoCharacter = '•'
                        t.PlaceholderStyle = styles.BlurredStyle
                        t.PromptStyle = styles.BlurredStyle
                        t.TextStyle = styles.BlurredStyle</span>
                }

                <span class="cov0" title="0">login.inputs[i] = t</span>
        }

        <span class="cov0" title="0">return login</span>
}

// Init - метод инициализации окна
func (m AuthModel) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

// Update - метод для обновления окна по внешним сообщениям
func (m AuthModel) Update(msg tea.Msg) (AuthModel, tea.Cmd) <span class="cov0" title="0">{
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.windowSize = msg
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "tab", "shift+tab", "up", "down":<span class="cov0" title="0">
                        // Сначала обрабатываем навигацию
                        s := msg.String()

                        if s == "up" || s == "shift+tab" </span><span class="cov0" title="0">{
                                m.focused--
                        }</span> else<span class="cov0" title="0"> {
                                m.focused++
                        }</span>

                        <span class="cov0" title="0">if m.focused &gt; len(m.inputs)-1 </span><span class="cov0" title="0">{
                                m.focused = 0
                        }</span> else<span class="cov0" title="0"> if m.focused &lt; 0 </span><span class="cov0" title="0">{
                                m.focused = len(m.inputs) - 1
                        }</span>

                        // Обновляем фокус только для активного поля
                        <span class="cov0" title="0">for i := range m.inputs </span><span class="cov0" title="0">{
                                if i == m.focused </span><span class="cov0" title="0">{
                                        cmds = append(cmds, m.inputs[i].Focus())
                                        m.inputs[i].PromptStyle = styles.FocusedStyle
                                        m.inputs[i].TextStyle = styles.FocusedStyle
                                }</span> else<span class="cov0" title="0"> {
                                        m.inputs[i].Blur()
                                        m.inputs[i].PromptStyle = styles.BlurredStyle
                                        m.inputs[i].TextStyle = styles.BlurredStyle
                                }</span>
                        }

                        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>

                case "enter":<span class="cov0" title="0">
                        username := m.inputs[0].Value()
                        password := m.inputs[1].Value()
                        return m, m.attemptLogin(username, password)</span>

                case "esc":<span class="cov0" title="0">
                        return m, func() tea.Msg </span><span class="cov0" title="0">{
                                return messages.GotoMainPageMsg{}
                        }</span>
                }
        }

        <span class="cov0" title="0">if m.focused &gt;= 0 &amp;&amp; m.focused &lt; len(m.inputs) </span><span class="cov0" title="0">{
                var cmd tea.Cmd
                m.inputs[m.focused], cmd = m.inputs[m.focused].Update(msg)
                if cmd != nil </span><span class="cov0" title="0">{
                        cmds = append(cmds, cmd)
                }</span>
        }

        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
}

// View - метод для отрисовки окна, в зависимости от текущего состояния
func (m AuthModel) View() string <span class="cov0" title="0">{
        // Поля ввода
        fields := make([]string, len(m.inputs))
        for i := range m.inputs </span><span class="cov0" title="0">{
                var inputStyle lipgloss.Style
                if i == m.focused </span><span class="cov0" title="0">{
                        inputStyle = styles.FocusedInputFieldStyle
                }</span> else<span class="cov0" title="0"> {
                        inputStyle = styles.InputFieldStyle
                }</span>

                <span class="cov0" title="0">fieldName := ""
                switch i </span>{
                case 0:<span class="cov0" title="0">
                        fieldName = "👤 Имя пользователя"</span>
                case 1:<span class="cov0" title="0">
                        fieldName = "🔒 Пароль"</span>
                }

                // Для неактивных полей показываем только значение, без курсора и т.д.
                <span class="cov0" title="0">var fieldView string
                if i == m.focused </span><span class="cov0" title="0">{
                        fieldView = m.inputs[i].View()
                }</span> else<span class="cov0" title="0"> {
                        // Для неактивного поля создаем "статическое" представление
                        value := m.inputs[i].Value()
                        if i == 1 &amp;&amp; value != "" </span><span class="cov0" title="0">{
                                // Для пароля показываем звездочки
                                stars := make([]rune, len(value))
                                for j := range stars </span><span class="cov0" title="0">{
                                        stars[j] = '•'
                                }</span>
                                <span class="cov0" title="0">fieldView = string(stars)</span>
                        } else<span class="cov0" title="0"> {
                                fieldView = value
                                if fieldView == "" </span><span class="cov0" title="0">{
                                        fieldView = " "
                                }</span>
                        }
                }

                <span class="cov0" title="0">fields[i] = lipgloss.JoinVertical(
                        lipgloss.Left,
                        styles.InputLabelStyle.Render(fieldName),
                        inputStyle.Render(fieldView),
                )</span>
        }

        // Основной контент
        <span class="cov0" title="0">content := lipgloss.JoinVertical(
                lipgloss.Center,
                styles.TitleStyle.
                        Width(40).
                        Render("🔐 Вход в систему"),

                lipgloss.NewStyle().Height(1).Render(""),

                lipgloss.JoinVertical(lipgloss.Left, fields...),

                lipgloss.NewStyle().Height(1).Render(""),

                // Кнопки действий
                lipgloss.JoinHorizontal(
                        lipgloss.Center,
                        styles.ButtonStyle.Render("Enter - Войти"),
                        styles.DividerStyle.Render(),
                        styles.ButtonStyle.Render("ESC - Назад"),
                ),
        )

        // Сообщение об ошибке
        if m.err != "" </span><span class="cov0" title="0">{
                content = lipgloss.JoinVertical(
                        lipgloss.Center,
                        content,
                        lipgloss.NewStyle().Height(1).Render(""),
                        styles.ErrorStyle.Render("❌ "+string(m.err)),
                )
        }</span>

        // Подсказка
        <span class="cov0" title="0">content = lipgloss.JoinVertical(
                lipgloss.Center,
                content,
                lipgloss.NewStyle().Height(1).Render(""),
                styles.HelpStyle.Render("Tab: переключение полей • Enter: подтвердить • ESC: назад"),
        )

        return styles.ContainerStyle.
                Width(m.windowSize.Width).
                Height(m.windowSize.Height).
                Render(
                        lipgloss.Place(
                                m.windowSize.Width, m.windowSize.Height,
                                lipgloss.Center, lipgloss.Center,
                                content,
                                lipgloss.WithWhitespaceChars(" "),
                                lipgloss.WithWhitespaceForeground(styles.BackgroundColor),
                        ),
                )</span>
}

// attemptLogin - метод обработки прохождения авторизации пользователя
func (m AuthModel) attemptLogin(username string, password string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if username == "" || password == "" </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("заполните все поля")
                }</span>
                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), time.Duration(m.connection.Timeout)*time.Second)
                client := grpcclient.NewUserClient(m.connection.ServerAddress())
                defer func() </span><span class="cov0" title="0">{
                        cancel()
                        client.Close()
                }</span>()
                <span class="cov0" title="0">if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка подключения к %s: %s", m.connection.ServerAddress(), err.Error()))
                }</span>
                <span class="cov0" title="0">token, salt, err := client.Login(username, password)
                if err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка авторизации пользователя %s: %s", username, err.Error()))
                }</span>
                <span class="cov0" title="0">return messages.AuthSuccessMsg{Token: token, Username: username, Salt: salt}</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package models

import (
        "go-pass-keeper/internal/models"
        "go-pass-keeper/internal/tui/messages"
        "go-pass-keeper/internal/tui/styles"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// BankCardSecretModel - модель окна создания/просмотра секрета (банковская карта)
type BankCardSecretModel struct {
        cardInputs []textinput.Model
        focused    int
        windowSize tea.WindowSizeMsg
        isEditMode bool   // Флаг режима редактирования
        sid        string // id для редактирования
}

// NewBankCardSecretModel - метод создания модель окна секрета (банковская карта)
func NewBankCardSecretModel() BankCardSecretModel <span class="cov0" title="0">{
        model := BankCardSecretModel{
                focused:    0,
                isEditMode: false,
        }

        model.cardInputs = make([]textinput.Model, 5)
        for i := range model.cardInputs </span><span class="cov0" title="0">{
                t := textinput.New()
                t.TextStyle = styles.BlurredStyle
                t.CharLimit = 50
                t.PromptStyle = styles.BlurredStyle

                switch i </span>{
                case 0:<span class="cov0" title="0">
                        t.Placeholder = "Имя карты"
                        t.CharLimit = 100</span>
                case 1:<span class="cov0" title="0">
                        t.Placeholder = "Номер карты"
                        t.CharLimit = 19</span>
                case 2:<span class="cov0" title="0">
                        t.Placeholder = "Срок действия (MM/YY)"
                        t.CharLimit = 5</span>
                case 3:<span class="cov0" title="0">
                        t.Placeholder = "CVV код"
                        t.CharLimit = 3</span>
                case 4:<span class="cov0" title="0">
                        t.Placeholder = "Имя владельца"</span>
                }

                <span class="cov0" title="0">model.cardInputs[i] = t</span>
        }

        <span class="cov0" title="0">model.cardInputs[0].Focus()
        model.cardInputs[0].PromptStyle = styles.FocusedStyle
        model.cardInputs[0].TextStyle = styles.FocusedStyle

        return model</span>
}

// Init - метод инициализации текущего окна
func (m BankCardSecretModel) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

// Update - метод обновления текущего окна
func (m BankCardSecretModel) Update(msg tea.Msg) (BankCardSecretModel, tea.Cmd) <span class="cov0" title="0">{
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.windowSize = msg
                return m, nil</span>

        case messages.GetSecretCardMsg:<span class="cov0" title="0">
                // Переключаемся в режим редактирования при получении данных
                m.isEditMode = true
                m.sid = msg.ID

                // Заполняем поля данными для просмотра
                m.cardInputs[0].SetValue(msg.Data.Name)
                m.cardInputs[1].SetValue(msg.Data.Number)
                m.cardInputs[2].SetValue(msg.Data.Date)
                m.cardInputs[3].SetValue(msg.Data.CVV)
                m.cardInputs[4].SetValue(msg.Data.Owner)
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                // Режим редактирования
                switch msg.String() </span>{
                case "tab", "shift+tab", "up", "down":<span class="cov0" title="0">
                        s := msg.String()

                        // Сбрасываем фокус со всех полей
                        for i := range m.cardInputs </span><span class="cov0" title="0">{
                                m.cardInputs[i].Blur()
                                m.cardInputs[i].PromptStyle = styles.BlurredStyle
                                m.cardInputs[i].TextStyle = styles.BlurredStyle
                        }</span>

                        <span class="cov0" title="0">if s == "up" || s == "shift+tab" </span><span class="cov0" title="0">{
                                m.focused--
                        }</span> else<span class="cov0" title="0"> {
                                m.focused++
                        }</span>

                        <span class="cov0" title="0">if m.focused &gt; 4 </span><span class="cov0" title="0">{
                                m.focused = 0
                        }</span> else<span class="cov0" title="0"> if m.focused &lt; 0 </span><span class="cov0" title="0">{
                                m.focused = 4
                        }</span>

                        // Устанавливаем фокус только на активное поле
                        <span class="cov0" title="0">cmds = append(cmds, m.cardInputs[m.focused].Focus())
                        m.cardInputs[m.focused].PromptStyle = styles.FocusedStyle
                        m.cardInputs[m.focused].TextStyle = styles.FocusedStyle

                        return m, tea.Batch(cmds...)</span>

                case "enter":<span class="cov0" title="0">
                        name := m.cardInputs[0].Value()
                        number := m.cardInputs[1].Value()
                        date := m.cardInputs[2].Value()
                        cvv := m.cardInputs[3].Value()
                        owner := m.cardInputs[4].Value()
                        if m.isEditMode </span><span class="cov0" title="0">{
                                m.isEditMode = false
                                return m, m.attemptEditSecret(m.sid, name, number, date, cvv, owner)
                        }</span>
                        <span class="cov0" title="0">return m, m.attemptAddSecret(name, number, date, cvv, owner)</span>

                case "esc":<span class="cov0" title="0">
                        m.isEditMode = false
                        return m, func() tea.Msg </span><span class="cov0" title="0">{
                                return messages.SecretAddCancelMsg{}
                        }</span>
                }
        }

        // Обрабатываем ввод ТОЛЬКО для активного поля в режиме редактирования
        <span class="cov0" title="0">if m.focused &gt;= 0 &amp;&amp; m.focused &lt; len(m.cardInputs) </span><span class="cov0" title="0">{
                var cmd tea.Cmd
                m.cardInputs[m.focused], cmd = m.cardInputs[m.focused].Update(msg)
                if cmd != nil </span><span class="cov0" title="0">{
                        cmds = append(cmds, cmd)
                }</span>
        }

        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
}

// View - метод отрисовки текущего состояния
func (m BankCardSecretModel) View() string <span class="cov0" title="0">{
        fields := []string{
                m.renderInputField("📝 Имя карты:", m.cardInputs[0], 0),
                m.renderInputField("💳 Номер карты:", m.cardInputs[1], 1),
                m.renderInputField("📅 Срок действия:", m.cardInputs[2], 2),
                m.renderInputField("🔒 CVV код:", m.cardInputs[3], 3),
                m.renderInputField("👤 Владелец:", m.cardInputs[4], 4),
        }

        // Заголовок в зависимости от режима
        title := "💳 Банковская карта"

        // Кнопки в зависимости от режима
        buttons := lipgloss.JoinHorizontal(
                lipgloss.Center,
                styles.ButtonStyle.Render("Enter - Применить"),
                styles.DividerStyle.Render(),
                styles.ButtonStyle.Render("ESC - Отмена"),
        )

        content := lipgloss.JoinVertical(
                lipgloss.Center,
                styles.TitleStyle.
                        Width(50).
                        Render(title),

                lipgloss.NewStyle().Height(1).Render(""),

                lipgloss.JoinVertical(lipgloss.Left, fields...),

                lipgloss.NewStyle().Height(1).Render(""),

                buttons,
        )

        return styles.ContainerStyle.
                Width(m.windowSize.Width).
                Height(m.windowSize.Height).
                Render(
                        lipgloss.Place(
                                m.windowSize.Width, m.windowSize.Height,
                                lipgloss.Center, lipgloss.Center,
                                content,
                                lipgloss.WithWhitespaceChars(" "),
                                lipgloss.WithWhitespaceForeground(styles.BackgroundColor),
                        ),
                )
}</span>

// renderInputField - метод для отрисовки полей ввода
func (m BankCardSecretModel) renderInputField(label string, input textinput.Model, index int) string <span class="cov0" title="0">{
        var inputStyle lipgloss.Style
        if index == m.focused </span><span class="cov0" title="0">{
                inputStyle = styles.FocusedInputFieldStyle
        }</span> else<span class="cov0" title="0"> {
                inputStyle = styles.InputFieldStyle
        }</span>

        <span class="cov0" title="0">var fieldView string
        // Режим редактирования
        if index == m.focused </span><span class="cov0" title="0">{
                // Активное поле - показываем с курсором
                fieldView = input.View()
        }</span> else<span class="cov0" title="0"> {
                // Неактивное поле - показываем текущее значение
                value := input.Value()
                fieldView = value
                if fieldView == "" </span><span class="cov0" title="0">{
                        fieldView = input.Placeholder
                }</span>
        }

        <span class="cov0" title="0">return lipgloss.JoinVertical(
                lipgloss.Left,
                styles.InputLabelStyle.Render(label),
                inputStyle.Render(fieldView),
        ) + "\n"</span>
}

// attemptAddSecret - метод обработки добавления секрета
func (m BankCardSecretModel) attemptAddSecret(name string, number string, date string, cvv string, owner string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if len(name) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать имя секрета")
                }</span>
                <span class="cov0" title="0">if len(number) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать номер карты")
                }</span>
                <span class="cov0" title="0">if len(date) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать дату выдачи карты")
                }</span>
                <span class="cov0" title="0">if len(cvv) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать CVV карты")
                }</span>
                <span class="cov0" title="0">if len(owner) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать владельца карты")
                }</span>
                <span class="cov0" title="0">return messages.AddSecretCardMsg{
                        Data: messages.SecretCard{
                                Name:   name,
                                Type:   models.SecretCardType,
                                Number: number,
                                CVV:    cvv,
                                Date:   date,
                                Owner:  owner,
                        },
                }</span>
        }
}

// attemptEditSecret - метод обработки изменения секрета
func (m BankCardSecretModel) attemptEditSecret(sid string, name string, number string, date string, cvv string, owner string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if len(name) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать имя секрета")
                }</span>
                <span class="cov0" title="0">if len(number) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать номер карты")
                }</span>
                <span class="cov0" title="0">if len(date) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать дату выдачи карты")
                }</span>
                <span class="cov0" title="0">if len(cvv) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать CVV карты")
                }</span>
                <span class="cov0" title="0">if len(owner) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать владельца карты")
                }</span>
                <span class="cov0" title="0">return messages.EditSecretCardMsg{
                        ID: sid,
                        Data: messages.SecretCard{
                                Name:   name,
                                Type:   models.SecretCardType,
                                Number: number,
                                CVV:    cvv,
                                Date:   date,
                                Owner:  owner,
                        },
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package models

import (
        "go-pass-keeper/internal/models"
        "go-pass-keeper/internal/tui/messages"
        "go-pass-keeper/internal/tui/styles"
        "os"
        "path/filepath"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// FileSecretModel - модель окна создания/просмотра секрета (файл)
type FileSecretModel struct {
        filePathInput textinput.Model
        windowSize    tea.WindowSizeMsg
        isEditMode    bool   // Флаг режима редактирования
        sid           string // id для редактирования
        secretData    []byte // Данные
}

// NewFileSecretModel - метод создания модель окна секрета (файл)
func NewFileSecretModel() FileSecretModel <span class="cov0" title="0">{
        model := FileSecretModel{
                isEditMode: false,
        }

        model.filePathInput = textinput.New()
        model.filePathInput.Placeholder = "Введите путь к файлу"
        model.filePathInput.CharLimit = 255
        model.filePathInput.TextStyle = styles.FocusedStyle
        model.filePathInput.PromptStyle = styles.FocusedStyle

        model.filePathInput.Focus()

        return model
}</span>

// Init - метод инициализации текущего окна
func (m FileSecretModel) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

// Update - метод обновления текущего окна
func (m FileSecretModel) Update(msg tea.Msg) (FileSecretModel, tea.Cmd) <span class="cov0" title="0">{
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.windowSize = msg
                return m, nil</span>

        case messages.GetSecretBinaryMsg:<span class="cov0" title="0">
                // Переключаемся в режим редактирования при получении данных
                m.isEditMode = true
                m.sid = msg.ID
                m.secretData = msg.Data.Blob
                // Заполняем поле данными для просмотра
                m.filePathInput.SetValue(msg.Data.Name)
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                // Режим редактирования
                switch msg.String() </span>{
                case "ctrl+s":<span class="cov0" title="0">
                        return m, m.attemptSaveFile(m.filePathInput.Value(), m.secretData)</span>

                case "enter":<span class="cov0" title="0">
                        if m.isEditMode </span><span class="cov0" title="0">{
                                m.isEditMode = false
                                return m, m.attemptEditSecret(m.sid, m.filePathInput.Value())
                        }</span>
                        <span class="cov0" title="0">return m, m.attemptAddSecret(m.filePathInput.Value())</span>

                case "esc":<span class="cov0" title="0">
                        m.isEditMode = false
                        return m, func() tea.Msg </span><span class="cov0" title="0">{
                                return messages.SecretAddCancelMsg{}
                        }</span>
                }
        }

        <span class="cov0" title="0">var cmd tea.Cmd
        m.filePathInput, cmd = m.filePathInput.Update(msg)
        cmds = append(cmds, cmd)

        return m, tea.Batch(cmds...)</span>
}

// View - метод отрисовки текущего состояния
func (m FileSecretModel) View() string <span class="cov0" title="0">{
        fileInfo := ""

        if m.filePathInput.Value() != "" </span><span class="cov0" title="0">{
                // В режиме редактирования проверяем существование файла
                fileInfo = "Путь: " + m.filePathInput.Value()

                // Проверяем существование файла
                if _, err := os.Stat(m.filePathInput.Value()); err == nil </span><span class="cov0" title="0">{
                        fileInfo += " ✓ Файл существует"
                }</span> else<span class="cov0" title="0"> {
                        fileInfo += " ✗ Файл не найден"
                }</span>
        }

        <span class="cov0" title="0">title := "📁 Укажите путь к файлу"
        buttons := lipgloss.JoinHorizontal(
                lipgloss.Center,
                styles.ButtonStyle.Render("Enter - Применить"),
                styles.DividerStyle.Render(),
                styles.ButtonStyle.Render("Ctrl+S - Сохранить"),
                styles.DividerStyle.Render(),
                styles.ButtonStyle.Render("ESC - Отмена"),
        )
        hint := "Введите полный путь к файлу для сохранения"

        content := lipgloss.JoinVertical(
                lipgloss.Center,
                styles.TitleStyle.
                        Width(40).
                        Render(title),

                lipgloss.NewStyle().Height(2).Render(""),

                m.renderInputField("📁 Имя файла:", m.filePathInput),

                lipgloss.NewStyle().Height(1).Render(""),

                lipgloss.NewStyle().
                        Foreground(styles.TextSecondary).
                        Italic(true).
                        Render(fileInfo),

                lipgloss.NewStyle().Height(2).Render(""),

                buttons,

                lipgloss.NewStyle().Height(1).Render(""),

                lipgloss.NewStyle().
                        Foreground(styles.TextSecondary).
                        Italic(true).
                        Render(hint),
        )

        return styles.ContainerStyle.
                Width(m.windowSize.Width).
                Height(m.windowSize.Height).
                Render(
                        lipgloss.Place(
                                m.windowSize.Width, m.windowSize.Height,
                                lipgloss.Center, lipgloss.Center,
                                content,
                                lipgloss.WithWhitespaceChars(" "),
                                lipgloss.WithWhitespaceForeground(styles.BackgroundColor),
                        ),
                )</span>
}

// renderInputField - метод для отрисовки полей ввода
func (m FileSecretModel) renderInputField(label string, input textinput.Model) string <span class="cov0" title="0">{
        return lipgloss.JoinVertical(
                lipgloss.Left,
                styles.InputLabelStyle.Render(label),
                styles.FocusedInputFieldStyle.Width(60).Render(input.View()),
        ) + "\n"
}</span>

// attemptAddSecret - метод обработки добавления секрета
func (m FileSecretModel) attemptAddSecret(filename string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if filename == "" </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать имя файла")
                }</span>
                // Проверяем существование файла
                <span class="cov0" title="0">if _, err := os.Stat(m.filePathInput.Value()); err == nil </span><span class="cov0" title="0">{
                        // Читаем содержимое файла
                        content, err := os.ReadFile(m.filePathInput.Value())
                        if err != nil </span><span class="cov0" title="0">{
                                return messages.ErrorMsg("Ошибка чтения файла")
                        }</span>
                        <span class="cov0" title="0">return messages.AddSecretBinaryMsg{
                                Data: messages.SecretBinary{
                                        Name: filepath.Base(filename),
                                        Type: models.SecretBinaryType,
                                        Blob: content,
                                },
                        }</span>
                }
                <span class="cov0" title="0">return messages.ErrorMsg("Файл не найден или недоступен")</span>
        }
}

// attemptEditSecret - метод обработки изменения секрета
func (m FileSecretModel) attemptEditSecret(sid string, filename string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if filename == "" </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать имя файла")
                }</span>
                // Проверяем существование файла
                <span class="cov0" title="0">if _, err := os.Stat(m.filePathInput.Value()); err == nil </span><span class="cov0" title="0">{
                        // Читаем содержимое файла
                        content, err := os.ReadFile(m.filePathInput.Value())
                        if err != nil </span><span class="cov0" title="0">{
                                return messages.ErrorMsg("Ошибка чтения файла")
                        }</span>
                        <span class="cov0" title="0">return messages.EditSecretBinaryMsg{
                                ID: sid,
                                Data: messages.SecretBinary{
                                        Name: filepath.Base(filename),
                                        Type: models.SecretBinaryType,
                                        Blob: content,
                                },
                        }</span>
                }
                <span class="cov0" title="0">return messages.ErrorMsg("Файл не найден или недоступен")</span>
        }
}

// attemptSaveFile - метод сохранения файла на диск в режиме просмотра
func (m FileSecretModel) attemptSaveFile(filename string, blob []byte) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if blob == nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Нет данных для сохранения")
                }</span>

                // Проверяем, не существует ли файл
                <span class="cov0" title="0">if _, err := os.Stat(filename); err == nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Файл уже существует: " + filename)
                }</span>

                // Сохраняем файл
                <span class="cov0" title="0">err := os.WriteFile(filename, blob, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Ошибка сохранения файла: " + err.Error())
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package models

import (
        "go-pass-keeper/internal/models"
        "go-pass-keeper/internal/tui/messages"
        "go-pass-keeper/internal/tui/styles"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// LoginSecretModel - модель окна секрета (логин/пароль)
type LoginSecretModel struct {
        nameInput     textinput.Model
        loginInput    textinput.Model
        passwordInput textinput.Model
        focused       int
        windowSize    tea.WindowSizeMsg
        isEditMode    bool   // Флаг режима редактирования
        sid           string // id для редактирования
}

// Индексы полей
const (
        fieldNameIndex = iota
        fieldLoginIndex
        fieldPasswordIndex
)

// NewFileSecretModel - метод создания модель окна секрета (логин/пароль)
func NewLoginSecretModel() LoginSecretModel <span class="cov0" title="0">{
        model := LoginSecretModel{
                focused:    fieldNameIndex,
                isEditMode: false,
        }

        model.nameInput = textinput.New()
        model.nameInput.Placeholder = "Название аккаунта"
        model.nameInput.CharLimit = 50
        model.nameInput.TextStyle = styles.BlurredStyle
        model.nameInput.PromptStyle = styles.FocusedStyle

        model.loginInput = textinput.New()
        model.loginInput.Placeholder = "Логин или email"
        model.loginInput.CharLimit = 50
        model.loginInput.TextStyle = styles.BlurredStyle
        model.loginInput.PromptStyle = styles.BlurredStyle

        model.passwordInput = textinput.New()
        model.passwordInput.Placeholder = "Пароль"
        model.passwordInput.CharLimit = 50
        model.passwordInput.TextStyle = styles.BlurredStyle
        model.passwordInput.PromptStyle = styles.BlurredStyle

        model.nameInput.Focus()

        return model
}</span>

// Init - метод инициализации текущего окна
func (m LoginSecretModel) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

// Update - метод обновления текущего окна
func (m LoginSecretModel) Update(msg tea.Msg) (LoginSecretModel, tea.Cmd) <span class="cov0" title="0">{
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.windowSize = msg
                return m, nil</span>

        case messages.GetSecretPasswordMsg:<span class="cov0" title="0">
                // Переключаемся в режим просмотра при получении данных
                m.isEditMode = true
                m.sid = msg.ID
                // Заполняем поля данными для просмотра
                m.nameInput.SetValue(msg.Data.Name)
                m.loginInput.SetValue(msg.Data.Login)
                m.passwordInput.SetValue(msg.Data.Password)
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                // Режим редактирования
                switch msg.String() </span>{
                case "tab", "shift+tab", "up", "down":<span class="cov0" title="0">
                        s := msg.String()

                        // Сбрасываем стили всех полей
                        m.nameInput.Blur()
                        m.loginInput.Blur()
                        m.passwordInput.Blur()
                        m.nameInput.PromptStyle = styles.BlurredStyle
                        m.nameInput.TextStyle = styles.BlurredStyle
                        m.loginInput.PromptStyle = styles.BlurredStyle
                        m.loginInput.TextStyle = styles.BlurredStyle
                        m.passwordInput.PromptStyle = styles.BlurredStyle
                        m.passwordInput.TextStyle = styles.BlurredStyle

                        // Навигация по полям
                        if s == "up" || s == "shift+tab" </span><span class="cov0" title="0">{
                                m.focused--
                        }</span> else<span class="cov0" title="0"> {
                                m.focused++
                        }</span>

                        <span class="cov0" title="0">if m.focused &gt; fieldPasswordIndex </span><span class="cov0" title="0">{
                                m.focused = fieldNameIndex
                        }</span> else<span class="cov0" title="0"> if m.focused &lt; fieldNameIndex </span><span class="cov0" title="0">{
                                m.focused = fieldPasswordIndex
                        }</span>

                        // Устанавливаем фокус на активное поле
                        <span class="cov0" title="0">switch m.focused </span>{
                        case fieldNameIndex:<span class="cov0" title="0">
                                cmds = append(cmds, m.nameInput.Focus())
                                m.nameInput.PromptStyle = styles.FocusedStyle
                                m.nameInput.TextStyle = styles.FocusedStyle</span>
                        case fieldLoginIndex:<span class="cov0" title="0">
                                cmds = append(cmds, m.loginInput.Focus())
                                m.loginInput.PromptStyle = styles.FocusedStyle
                                m.loginInput.TextStyle = styles.FocusedStyle</span>
                        case fieldPasswordIndex:<span class="cov0" title="0">
                                cmds = append(cmds, m.passwordInput.Focus())
                                m.passwordInput.PromptStyle = styles.FocusedStyle
                                m.passwordInput.TextStyle = styles.FocusedStyle</span>
                        }
                        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>

                case "enter":<span class="cov0" title="0">
                        if m.isEditMode </span><span class="cov0" title="0">{
                                m.isEditMode = false // сбрасываем режим
                                return m, m.attemptEditSecret(m.sid, m.nameInput.Value(), m.loginInput.Value(), m.passwordInput.Value())
                        }</span>
                        <span class="cov0" title="0">return m, m.attemptAddSecret(m.nameInput.Value(), m.loginInput.Value(), m.passwordInput.Value())</span>

                case "esc":<span class="cov0" title="0">
                        m.isEditMode = false
                        return m, func() tea.Msg </span><span class="cov0" title="0">{
                                return messages.SecretAddCancelMsg{}
                        }</span>
                }
        }

        // Обновляем активное поле ввода
        <span class="cov0" title="0">var cmd tea.Cmd
        switch m.focused </span>{
        case fieldNameIndex:<span class="cov0" title="0">
                m.nameInput, cmd = m.nameInput.Update(msg)</span>
        case fieldLoginIndex:<span class="cov0" title="0">
                m.loginInput, cmd = m.loginInput.Update(msg)</span>
        case fieldPasswordIndex:<span class="cov0" title="0">
                m.passwordInput, cmd = m.passwordInput.Update(msg)</span>
        }

        <span class="cov0" title="0">if cmd != nil </span><span class="cov0" title="0">{
                cmds = append(cmds, cmd)
        }</span>

        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
}

// View - метод отрисовки текущего состояния
func (m LoginSecretModel) View() string <span class="cov0" title="0">{
        fields := []string{
                m.renderInputField("📝 Название:", m.nameInput, fieldNameIndex),
                m.renderInputField("👤 Логин:", m.loginInput, fieldLoginIndex),
                m.renderInputField("🔒 Пароль:", m.passwordInput, fieldPasswordIndex),
        }

        title := "🔐 Логин и пароль"
        buttons := lipgloss.JoinHorizontal(
                lipgloss.Center,
                styles.ButtonStyle.Render("Enter - Применить"),
                styles.DividerStyle.Render(),
                styles.ButtonStyle.Render("ESC - Отмена"),
        )

        content := lipgloss.JoinVertical(
                lipgloss.Center,
                styles.TitleStyle.
                        Width(40).
                        Render(title),

                lipgloss.NewStyle().Height(2).Render(""),

                lipgloss.JoinVertical(lipgloss.Left, fields...),

                lipgloss.NewStyle().Height(2).Render(""),

                buttons,
        )

        return styles.ContainerStyle.
                Width(m.windowSize.Width).
                Height(m.windowSize.Height).
                Render(
                        lipgloss.Place(
                                m.windowSize.Width, m.windowSize.Height,
                                lipgloss.Center, lipgloss.Center,
                                content,
                                lipgloss.WithWhitespaceChars(" "),
                                lipgloss.WithWhitespaceForeground(styles.BackgroundColor),
                        ),
                )
}</span>

// renderInputField - метод для отрисовки полей ввода
func (m LoginSecretModel) renderInputField(label string, input textinput.Model, index int) string <span class="cov0" title="0">{
        var inputStyle lipgloss.Style
        if index == m.focused </span><span class="cov0" title="0">{
                inputStyle = styles.FocusedInputFieldStyle
        }</span> else<span class="cov0" title="0"> {
                inputStyle = styles.InputFieldStyle
        }</span>

        <span class="cov0" title="0">var fieldView string
        if index == m.focused </span><span class="cov0" title="0">{
                fieldView = input.View()
        }</span> else<span class="cov0" title="0"> {
                value := input.Value()
                fieldView = value
                if fieldView == "" </span><span class="cov0" title="0">{
                        fieldView = " "
                }</span>
        }

        <span class="cov0" title="0">return lipgloss.JoinVertical(
                lipgloss.Left,
                styles.InputLabelStyle.Render(label),
                inputStyle.Render(fieldView),
        ) + "\n"</span>
}

// attemptAddSecret - метод обработки добавления секрета
func (m LoginSecretModel) attemptAddSecret(name string, username string, password string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if len(name) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать имя секрета")
                }</span>
                <span class="cov0" title="0">if len(username) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать пользователя")
                }</span>
                <span class="cov0" title="0">if len(password) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать пароль")
                }</span>
                <span class="cov0" title="0">return messages.AddSecretPasswordMsg{
                        Data: messages.SecretPassword{
                                Name:     name,
                                Type:     models.SecretPasswordType,
                                Login:    username,
                                Password: password,
                        },
                }</span>
        }
}

// attemptEditSecret - метод обработки изменения секрета
func (m LoginSecretModel) attemptEditSecret(sid string, name string, username string, password string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if len(name) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать имя секрета")
                }</span>
                <span class="cov0" title="0">if len(username) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать пользователя")
                }</span>
                <span class="cov0" title="0">if len(password) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать пароль")
                }</span>
                <span class="cov0" title="0">return messages.EditSecretPasswordMsg{
                        ID: sid,
                        Data: messages.SecretPassword{
                                Name:     name,
                                Type:     models.SecretPasswordType,
                                Login:    username,
                                Password: password,
                        },
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package models

import (
        "context"
        "fmt"
        "go-pass-keeper/internal/grpcclient"
        "go-pass-keeper/internal/grpcclient/settings"
        "go-pass-keeper/internal/tui/messages"
        "go-pass-keeper/internal/tui/styles"
        "time"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// RegisterModel - модель окна регистрации пользователя
type RegisterModel struct {
        inputs     []textinput.Model
        focused    int
        err        messages.ErrorMsg
        windowSize tea.WindowSizeMsg
        connection *settings.Settings
}

// NewLoginModel - метод для создания окна регистрации пользователя
func NewRegisterModel(connection *settings.Settings) RegisterModel <span class="cov0" title="0">{
        register := RegisterModel{
                inputs:     make([]textinput.Model, 3),
                connection: connection,
        }

        for i := range register.inputs </span><span class="cov0" title="0">{
                t := textinput.New()
                t.Cursor.Style = styles.FocusedStyle
                t.CharLimit = 32
                t.TextStyle = styles.BlurredStyle

                switch i </span>{
                case 0:<span class="cov0" title="0">
                        t.Placeholder = "Введите имя пользователя"
                        t.PlaceholderStyle = styles.BlurredStyle</span>
                case 1:<span class="cov0" title="0">
                        t.Placeholder = "Введите пароль"
                        t.EchoMode = textinput.EchoPassword
                        t.EchoCharacter = '•'
                        t.PlaceholderStyle = styles.BlurredStyle</span>
                case 2:<span class="cov0" title="0">
                        t.Placeholder = "Подтвердите пароль"
                        t.EchoMode = textinput.EchoPassword
                        t.EchoCharacter = '•'
                        t.PlaceholderStyle = styles.BlurredStyle</span>
                }

                <span class="cov0" title="0">register.inputs[i] = t</span>
        }

        <span class="cov0" title="0">return register</span>
}

// Init - метод инициализации окна
func (m RegisterModel) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

// Update - метод для обновления окна по внешним сообщениям
func (m RegisterModel) Update(msg tea.Msg) (RegisterModel, tea.Cmd) <span class="cov0" title="0">{
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.windowSize = msg
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "tab", "shift+tab", "enter", "up", "down":<span class="cov0" title="0">
                        s := msg.String()

                        if s == "enter" </span><span class="cov0" title="0">{
                                username := m.inputs[0].Value()
                                password := m.inputs[1].Value()
                                confirm := m.inputs[2].Value()
                                return m, m.attemptRegister(username, password, confirm)
                        }</span>

                        <span class="cov0" title="0">if s == "up" || s == "shift+tab" </span><span class="cov0" title="0">{
                                m.focused--
                        }</span> else<span class="cov0" title="0"> {
                                m.focused++
                        }</span>

                        <span class="cov0" title="0">if m.focused &gt; len(m.inputs)-1 </span><span class="cov0" title="0">{
                                m.focused = 0
                        }</span> else<span class="cov0" title="0"> if m.focused &lt; 0 </span><span class="cov0" title="0">{
                                m.focused = len(m.inputs) - 1
                        }</span>

                        <span class="cov0" title="0">for i := range m.inputs </span><span class="cov0" title="0">{
                                if i == m.focused </span><span class="cov0" title="0">{
                                        cmds = append(cmds, m.inputs[i].Focus())
                                        m.inputs[i].PromptStyle = styles.FocusedStyle
                                        m.inputs[i].TextStyle = styles.FocusedStyle
                                        continue</span>
                                }
                                <span class="cov0" title="0">m.inputs[i].Blur()
                                m.inputs[i].PromptStyle = styles.BlurredStyle
                                m.inputs[i].TextStyle = styles.BlurredStyle</span>
                        }

                        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
                }
        }

        <span class="cov0" title="0">for i := range m.inputs </span><span class="cov0" title="0">{
                var cmd tea.Cmd
                m.inputs[i], cmd = m.inputs[i].Update(msg)
                cmds = append(cmds, cmd)
        }</span>

        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
}

// View - метод для отрисовки окна, в зависимости от текущего состояния
func (m RegisterModel) View() string <span class="cov0" title="0">{

        // Поля ввода
        fields := make([]string, len(m.inputs))
        for i := range m.inputs </span><span class="cov0" title="0">{
                var inputStyle lipgloss.Style
                if i == m.focused </span><span class="cov0" title="0">{
                        inputStyle = styles.FocusedInputFieldStyle
                }</span> else<span class="cov0" title="0"> {
                        inputStyle = styles.InputFieldStyle
                }</span>

                <span class="cov0" title="0">fieldName := ""
                switch i </span>{
                case 0:<span class="cov0" title="0">
                        fieldName = "👤 Имя пользователя"</span>
                case 1:<span class="cov0" title="0">
                        fieldName = "🔒 Пароль"</span>
                case 2:<span class="cov0" title="0">
                        fieldName = "✅ Подтверждение пароля"</span>
                }

                <span class="cov0" title="0">fields[i] = lipgloss.JoinVertical(
                        lipgloss.Left,
                        styles.InputLabelStyle.Render(fieldName),
                        inputStyle.Render(m.inputs[i].View()),
                )</span>
        }

        // Основной контент
        <span class="cov0" title="0">content := lipgloss.JoinVertical(
                lipgloss.Center,
                styles.TitleStyle.
                        Width(40).
                        Render("📝 Регистрация"),

                lipgloss.NewStyle().Height(1).Render(""),

                lipgloss.JoinVertical(lipgloss.Left, fields...),

                lipgloss.NewStyle().Height(1).Render(""),

                // Кнопки действий
                lipgloss.JoinHorizontal(
                        lipgloss.Center,
                        styles.ButtonStyle.Render("Enter - Зарегистрироваться"),
                        styles.DividerStyle.Render(),
                        styles.ButtonStyle.Render("ESC - Назад"),
                ),
        )

        // Сообщение об ошибке
        if m.err != "" </span><span class="cov0" title="0">{
                content = lipgloss.JoinVertical(
                        lipgloss.Center,
                        content,
                        lipgloss.NewStyle().Height(1).Render(""),
                        styles.ErrorStyle.Render("❌ "+string(m.err)),
                )
        }</span>

        // Подсказка
        <span class="cov0" title="0">content = lipgloss.JoinVertical(
                lipgloss.Center,
                content,
                lipgloss.NewStyle().Height(1).Render(""),
                styles.HelpStyle.Render("Tab: переключение полей • Enter: подтвердить • ESC: назад"),
        )

        return styles.ContainerStyle.
                Width(m.windowSize.Width).
                Height(m.windowSize.Height).
                Render(
                        lipgloss.Place(
                                m.windowSize.Width, m.windowSize.Height,
                                lipgloss.Center, lipgloss.Center,
                                content,
                                lipgloss.WithWhitespaceChars(" "),
                                lipgloss.WithWhitespaceForeground(styles.BackgroundColor),
                        ),
                )</span>
}

// attemptRegister - метод обработки прохождения регистрации пользователя
func (m RegisterModel) attemptRegister(username string, password string, confirm string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if username == "" || password == "" || confirm == "" </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("заполните все поля")
                }</span>
                <span class="cov0" title="0">if password != confirm </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("пароли не совпадают")
                }</span>
                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), time.Duration(m.connection.Timeout)*time.Second)
                client := grpcclient.NewUserClient(m.connection.ServerAddress())
                defer func() </span><span class="cov0" title="0">{
                        cancel()
                        client.Close()
                }</span>()
                <span class="cov0" title="0">if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка подключения к %s: %s", m.connection.ServerAddress(), err.Error()))
                }</span>
                <span class="cov0" title="0">token, salt, err := client.Register(username, password)
                if err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка регистрации пользователя %s: %s", username, err.Error()))
                }</span>
                <span class="cov0" title="0">return messages.AuthSuccessMsg{Token: token, Username: username, Salt: salt}</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package models

import (
        "fmt"
        "go-pass-keeper/internal/grpcclient/settings"
        "go-pass-keeper/internal/tui/messages"
        "go-pass-keeper/internal/tui/styles"
        "strconv"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// SettingsModel - модель окна настроек
type SettingsModel struct {
        inputs     []textinput.Model
        focused    int
        windowSize tea.WindowSizeMsg
        connection *settings.Settings
}

// Константы для именованных индексов полей
const (
        fieldServerURL = iota
        fieldServerPort
        fieldTimeout
        fieldSecretPassword
)

// NewSettingsModel - метод для создания окна настроек
func NewSettingsModel(connection *settings.Settings) SettingsModel <span class="cov0" title="0">{
        model := SettingsModel{
                inputs:     make([]textinput.Model, 4),
                connection: connection,
        }

        // Инициализация полей ввода
        for i := range model.inputs </span><span class="cov0" title="0">{
                t := textinput.New()
                t.Cursor.Style = styles.FocusedStyle
                t.TextStyle = styles.BlurredStyle
                t.CharLimit = 50

                switch i </span>{
                case fieldServerURL:<span class="cov0" title="0">
                        t.Placeholder = "localhost"
                        t.Prompt = "URL сервера: "
                        t.SetValue(connection.ServerURL)</span>
                case fieldServerPort:<span class="cov0" title="0">
                        t.Placeholder = "8080"
                        t.Prompt = "Порт: "
                        t.SetValue(connection.ServerPort)</span>
                case fieldTimeout:<span class="cov0" title="0">
                        t.Placeholder = "30"
                        t.Prompt = "Таймаут (секунды): "
                        t.SetValue(fmt.Sprintf("%d", connection.Timeout))</span>
                case fieldSecretPassword:<span class="cov0" title="0">
                        t.Placeholder = "Секрет"
                        t.Prompt = "Секрет: "
                        t.EchoMode = textinput.EchoPassword
                        t.EchoCharacter = '•'
                        t.SetValue(connection.Secret)</span>
                }

                <span class="cov0" title="0">model.inputs[i] = t</span>
        }

        <span class="cov0" title="0">return model</span>
}

// Init - метод инициализации окна
func (m SettingsModel) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

// Update - метод для обновления окна по внешним сообщениям
func (m SettingsModel) Update(msg tea.Msg) (SettingsModel, tea.Cmd) <span class="cov0" title="0">{
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.windowSize = msg
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "tab", "shift+tab", "enter", "up", "down":<span class="cov0" title="0">
                        s := msg.String()

                        if s == "enter" </span><span class="cov0" title="0">{
                                // Сохраняем настройки
                                newConnection := settings.Settings{
                                        ServerURL:  m.inputs[fieldServerURL].Value(),
                                        ServerPort: m.inputs[fieldServerPort].Value(),
                                        Secret:     m.inputs[fieldSecretPassword].Value(),
                                }

                                // Парсим таймаут
                                if timeout, err := strconv.Atoi(m.inputs[fieldTimeout].Value()); err == nil </span><span class="cov0" title="0">{
                                        newConnection.Timeout = timeout
                                }</span> else<span class="cov0" title="0"> {
                                        newConnection.Timeout = 30
                                }</span>

                                <span class="cov0" title="0">return m, func() tea.Msg </span><span class="cov0" title="0">{
                                        return messages.ConfigUpdatedMsg{Connection: newConnection}
                                }</span>
                        }

                        <span class="cov0" title="0">if s == "up" || s == "shift+tab" </span><span class="cov0" title="0">{
                                m.focused--
                        }</span> else<span class="cov0" title="0"> {
                                m.focused++
                        }</span>

                        <span class="cov0" title="0">if m.focused &gt; len(m.inputs)-1 </span><span class="cov0" title="0">{
                                m.focused = 0
                        }</span> else<span class="cov0" title="0"> if m.focused &lt; 0 </span><span class="cov0" title="0">{
                                m.focused = len(m.inputs) - 1
                        }</span>

                        <span class="cov0" title="0">for i := range m.inputs </span><span class="cov0" title="0">{
                                if i == m.focused </span><span class="cov0" title="0">{
                                        cmds = append(cmds, m.inputs[i].Focus())
                                        m.inputs[i].PromptStyle = styles.FocusedStyle
                                        m.inputs[i].TextStyle = styles.FocusedStyle
                                        continue</span>
                                }
                                <span class="cov0" title="0">m.inputs[i].Blur()
                                m.inputs[i].PromptStyle = styles.BlurredStyle
                                m.inputs[i].TextStyle = styles.BlurredStyle</span>
                        }

                        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
                }
        }

        <span class="cov0" title="0">for i := range m.inputs </span><span class="cov0" title="0">{
                var cmd tea.Cmd
                m.inputs[i], cmd = m.inputs[i].Update(msg)
                cmds = append(cmds, cmd)
        }</span>

        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
}

// View - метод для отрисовки окна, в зависимости от текущего состояния
func (m SettingsModel) View() string <span class="cov0" title="0">{
        // Поля ввода
        fields := make([]string, len(m.inputs))
        for i := range m.inputs </span><span class="cov0" title="0">{
                var inputStyle lipgloss.Style
                if i == m.focused </span><span class="cov0" title="0">{
                        inputStyle = styles.FocusedInputFieldStyle
                }</span> else<span class="cov0" title="0"> {
                        inputStyle = styles.InputFieldStyle
                }</span>

                <span class="cov0" title="0">fields[i] = lipgloss.JoinHorizontal(
                        lipgloss.Left,
                        lipgloss.NewStyle().Width(20).Render(m.inputs[i].Prompt),
                        inputStyle.Width(30).Render(m.inputs[i].View()),
                )</span>
        }

        // Основной контент
        <span class="cov0" title="0">content := lipgloss.JoinVertical(
                lipgloss.Center,
                styles.TitleStyle.
                        Width(50).
                        Render("⚙️ Настройки"),

                lipgloss.NewStyle().Height(1).Render(""),

                lipgloss.JoinVertical(lipgloss.Left, fields...),

                lipgloss.NewStyle().Height(2).Render(""),

                // Кнопки действий
                lipgloss.JoinHorizontal(
                        lipgloss.Center,
                        styles.ButtonStyle.Render("Enter - Применить"),
                        styles.DividerStyle.Render(),
                        styles.ButtonStyle.Render("ESC - Отмена"),
                ),

                lipgloss.NewStyle().Height(1).Render(""),

                // Текущие настройки
                lipgloss.NewStyle().
                        Foreground(styles.TextSecondary).
                        Italic(true).
                        Render(fmt.Sprintf("Текущее подключение: %s:%s",
                                m.connection.ServerURL,
                                m.connection.ServerPort)),
        )

        return styles.ContainerStyle.
                Width(m.windowSize.Width).
                Height(m.windowSize.Height).
                Render(
                        lipgloss.Place(
                                m.windowSize.Width, m.windowSize.Height,
                                lipgloss.Center, lipgloss.Center,
                                content,
                                lipgloss.WithWhitespaceChars(" "),
                                lipgloss.WithWhitespaceForeground(styles.BackgroundColor),
                        ),
                )</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package models

import (
        "go-pass-keeper/internal/models"
        "go-pass-keeper/internal/tui/messages"
        "go-pass-keeper/internal/tui/styles"

        "github.com/charmbracelet/bubbles/textarea"
        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// TextSecretModel - модель окна создания/просмотра текстового секрета
type TextSecretModel struct {
        nameInput  textinput.Model
        textArea   textarea.Model
        focused    bool
        windowSize tea.WindowSizeMsg
        isEditMode bool   // Флаг режима редактирования
        sid        string // id для редактирования
}

// NewTextSecretModel - метод создания модель окна создания/просмотра текстового секрета
func NewTextSecretModel() TextSecretModel <span class="cov0" title="0">{
        model := TextSecretModel{
                focused:    false,
                isEditMode: false,
        }

        model.nameInput = textinput.New()
        model.nameInput.Placeholder = "Название"
        model.nameInput.CharLimit = 50
        model.nameInput.TextStyle = styles.BlurredStyle

        model.textArea = textarea.New()
        model.textArea.Placeholder = "Введите текст здесь..."
        model.textArea.SetWidth(50)
        model.textArea.SetHeight(8)

        model.nameInput.Focus()

        return model
}</span>

// Init - метод инициализации текущего окна
func (m TextSecretModel) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

// Update - метод обновления текущего окна
func (m TextSecretModel) Update(msg tea.Msg) (TextSecretModel, tea.Cmd) <span class="cov0" title="0">{
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.windowSize = msg
                m.textArea.SetWidth(msg.Width - 20)
                return m, nil</span>

        case messages.GetSecretTextMsg:<span class="cov0" title="0">
                // Переключаемся в режим редактирования при получении данных
                m.isEditMode = true
                m.sid = msg.ID

                // Заполняем поля данными для просмотра
                m.nameInput.SetValue(msg.Data.Name)
                m.textArea.SetValue(msg.Data.Text)
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                // Режим редактирования
                switch msg.String() </span>{
                case "tab":<span class="cov0" title="0">
                        if m.focused </span><span class="cov0" title="0">{
                                m.textArea.Blur()
                                m.focused = false
                                return m, m.nameInput.Focus()
                        }</span> else<span class="cov0" title="0"> {
                                m.nameInput.Blur()
                                m.focused = true
                                return m, m.textArea.Focus()
                        }</span>

                case "enter":<span class="cov0" title="0">
                        if m.isEditMode </span><span class="cov0" title="0">{
                                m.isEditMode = false
                                return m, m.attemptEditSecret(m.sid, m.nameInput.Value(), m.textArea.Value())
                        }</span>
                        <span class="cov0" title="0">return m, m.attemptAddSecret(m.nameInput.Value(), m.textArea.Value())</span>

                case "esc":<span class="cov0" title="0">
                        m.isEditMode = false
                        return m, func() tea.Msg </span><span class="cov0" title="0">{
                                return messages.SecretAddCancelMsg{}
                        }</span>
                }
        }

        <span class="cov0" title="0">var cmd tea.Cmd
        if m.focused </span><span class="cov0" title="0">{
                m.textArea, cmd = m.textArea.Update(msg)
        }</span> else<span class="cov0" title="0"> {
                m.nameInput, cmd = m.nameInput.Update(msg)
        }</span>
        <span class="cov0" title="0">cmds = append(cmds, cmd)

        return m, tea.Batch(cmds...)</span>
}

// View - метод отрисовки текущего состояния
func (m TextSecretModel) View() string <span class="cov0" title="0">{
        title := "📝 Текст"
        buttons := lipgloss.JoinHorizontal(
                lipgloss.Center,
                styles.ButtonStyle.Render("Enter - Применить"),
                styles.DividerStyle.Render(),
                styles.ButtonStyle.Render("ESC - Отмена"),
        )
        hint := "Tab: переключение между полями"

        content := lipgloss.JoinVertical(
                lipgloss.Center,
                styles.TitleStyle.
                        Width(40).
                        Render(title),

                lipgloss.NewStyle().Height(1).Render(""),

                m.renderInputField("📝 Название:", m.nameInput),

                lipgloss.NewStyle().Height(1).Render(""),

                lipgloss.NewStyle().
                        Foreground(styles.TextSecondary).
                        Render("Текст:"),

                m.renderTextArea(m.textArea),

                lipgloss.NewStyle().Height(2).Render(""),

                buttons,

                lipgloss.NewStyle().Height(1).Render(""),

                lipgloss.NewStyle().
                        Foreground(styles.TextSecondary).
                        Italic(true).
                        Render(hint),
        )

        return styles.ContainerStyle.
                Width(m.windowSize.Width).
                Height(m.windowSize.Height).
                Render(
                        lipgloss.Place(
                                m.windowSize.Width, m.windowSize.Height,
                                lipgloss.Center, lipgloss.Center,
                                content,
                                lipgloss.WithWhitespaceChars(" "),
                                lipgloss.WithWhitespaceForeground(styles.BackgroundColor),
                        ),
                )
}</span>

// renderInputField - метод для отрисовки полей ввода
func (m TextSecretModel) renderInputField(label string, input textinput.Model) string <span class="cov0" title="0">{
        var inputStyle lipgloss.Style
        if m.focused </span><span class="cov0" title="0">{
                inputStyle = styles.FocusedInputFieldStyle
        }</span> else<span class="cov0" title="0"> {
                inputStyle = styles.InputFieldStyle
        }</span>

        <span class="cov0" title="0">return lipgloss.JoinVertical(
                lipgloss.Left,
                styles.InputLabelStyle.Render(label),
                inputStyle.Render(input.View()),
        ) + "\n"</span>
}

// renderTextArea - метод отрисовки окна для ввода текста
func (m TextSecretModel) renderTextArea(area textarea.Model) string <span class="cov0" title="0">{
        return styles.InputFieldStyle.Width(60).Height(12).Render(area.View())
}</span>

// attemptAddSecret - метод обработки добавления секрета
func (m TextSecretModel) attemptAddSecret(name string, text string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if len(name) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать имя секрета")
                }</span>
                <span class="cov0" title="0">if len(text) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Пустой текст секрета")
                }</span>
                <span class="cov0" title="0">return messages.AddSecretTextMsg{
                        Data: messages.SecretText{
                                Name: name,
                                Type: models.SecretTextType,
                                Text: text,
                        },
                }</span>
        }
}

// attemptAddSecret - метод обработки добавления секрета
func (m TextSecretModel) attemptEditSecret(sid string, name string, text string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if len(name) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Необходимо задать имя секрета")
                }</span>
                <span class="cov0" title="0">if len(text) == 0 </span><span class="cov0" title="0">{
                        return messages.ErrorMsg("Пустой текст секрета")
                }</span>
                <span class="cov0" title="0">return messages.EditSecretTextMsg{
                        ID: sid,
                        Data: messages.SecretText{
                                Name: name,
                                Type: models.SecretTextType,
                                Text: text,
                        },
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package models

import (
        "context"
        "fmt"
        "go-pass-keeper/internal/grpcclient"
        "go-pass-keeper/internal/grpcclient/settings"
        "go-pass-keeper/internal/models"
        "go-pass-keeper/internal/tui/messages"
        "go-pass-keeper/internal/tui/styles"
        "go-pass-keeper/pkg/crypto"
        "time"

        "github.com/charmbracelet/bubbles/table"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

type ViewerState int

// Список состояний окна
const (
        ViewerListState ViewerState = iota
        SecretViewState
        SecretAddState
)

// Кнопки на главном окне
const (
        AddButton = iota
        ViewButton
        DeleteButton
        UpdateButton
)

// ViewerModel - модель окна секретов
type ViewerModel struct {
        state      ViewerState
        table      table.Model
        secrets    []*models.SecretInfo
        windowSize tea.WindowSizeMsg
        focusedBtn int
        addModel   SecretAddModel
        settings   *settings.Settings
        token      string
        cryptoKey  []byte
}

// NewViewerModel - метод создания окна секретов
func NewViewerModel(connection *settings.Settings) ViewerModel <span class="cov0" title="0">{
        return ViewerModel{
                state:      ViewerListState,
                table:      createTable(),
                focusedBtn: 0,
                addModel:   NewSecretAddModel(),
                settings:   connection,
        }
}</span>

// Init - метод инициализации текущего окна
func (m ViewerModel) Init() tea.Cmd <span class="cov0" title="0">{
        return m.attemptGetSecrets()
}</span>

// Update - метод обновления текущего окна
func (m ViewerModel) Update(msg tea.Msg) (ViewerModel, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                return m.updateWindowsSize(msg)</span>

        // обработка отмены выбора секрета
        case messages.SecretAddCancelMsg:<span class="cov0" title="0">
                m.state = ViewerListState
                return m.handleAddState(msg)</span>
        // обаботка аутентификации (формирование токена и ключа)
        case messages.AuthSuccessMsg:<span class="cov0" title="0">
                return m.handleAuthAction(msg)</span>

        // запрос на добавление секрета (логин/пароль)
        case messages.AddSecretPasswordMsg:<span class="cov0" title="0">
                m.state = ViewerListState
                return m, m.attemptAddSecret(&amp;msg)</span>
        // запрос на изменение  секрета (логин/пароль)
        case messages.EditSecretPasswordMsg:<span class="cov0" title="0">
                m.state = ViewerListState
                return m, m.attemptEditSecret(&amp;msg)</span>

        // запрос на добавление секрета (банковская карта)
        case messages.AddSecretCardMsg:<span class="cov0" title="0">
                m.state = ViewerListState
                return m, m.attemptAddSecret(&amp;msg)</span>
        // запрос на изменение  секрета (банковская карта)
        case messages.EditSecretCardMsg:<span class="cov0" title="0">
                m.state = ViewerListState
                return m, m.attemptEditSecret(&amp;msg)</span>

        // запрос на добавление секрета (текстовые даные)
        case messages.AddSecretTextMsg:<span class="cov0" title="0">
                m.state = ViewerListState
                return m, m.attemptAddSecret(&amp;msg)</span>
        // запрос на изменение  секрета (текстовые даные)
        case messages.EditSecretTextMsg:<span class="cov0" title="0">
                m.state = ViewerListState
                return m, m.attemptEditSecret(&amp;msg)</span>

        // запрос на добавление секрета (бинарные данные)
        case messages.AddSecretBinaryMsg:<span class="cov0" title="0">
                m.state = ViewerListState
                return m, m.attemptAddSecret(&amp;msg)</span>
        // запрос на изменение  секрета (бинарные данные)
        case messages.EditSecretBinaryMsg:<span class="cov0" title="0">
                m.state = ViewerListState
                return m, m.attemptEditSecret(&amp;msg)</span>

        // запрос на обновление секретов
        case messages.SecretUpdateMsg:<span class="cov0" title="0">
                return m, m.attemptGetSecrets()</span>
        // обновление таблицы секретов
        case messages.SecretRefreshMsg:<span class="cov0" title="0">
                m.secrets = msg.Secrets
                return m.refreshViewer(), nil</span>
        }

        <span class="cov0" title="0">switch m.state </span>{
        case SecretAddState:<span class="cov0" title="0">
                return m.handleAddState(msg)</span>
        case SecretViewState:<span class="cov0" title="0">
                return m.handleViewState(msg)</span>
        default:<span class="cov0" title="0">
                return m.handleListState(msg)</span>
        }
}

// updateWindowsSize - метод обновления размеров окон
func (m ViewerModel) updateWindowsSize(msg tea.WindowSizeMsg) (ViewerModel, tea.Cmd) <span class="cov0" title="0">{
        m.windowSize = msg

        // Передаем размеры окна всем дочерним моделям
        updatedAddModel, addModelCmd := m.addModel.Update(msg)
        m.addModel = updatedAddModel

        return m, tea.Batch(addModelCmd)
}</span>

// handleListState - метод обработки основного окна (таблица + кнопки)
func (m ViewerModel) handleListState(msg tea.Msg) (ViewerModel, tea.Cmd) <span class="cov0" title="0">{
        var cmd tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "r", "R":<span class="cov0" title="0"> // Обновление
                        return m.refreshViewer(), nil</span>

                case "left", "h":<span class="cov0" title="0"> // Навигация кнопок
                        if m.focusedBtn &gt; 0 </span><span class="cov0" title="0">{
                                m.focusedBtn--
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "right", "l":<span class="cov0" title="0"> // Навигация кнопок
                        if m.focusedBtn &lt; 3 </span><span class="cov0" title="0">{
                                m.focusedBtn++
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "enter":<span class="cov0" title="0"> // Обработка действий
                        return m.handleEnterAction()</span>
                case "esc":<span class="cov0" title="0"> // Выход из секретов
                        return m, func() tea.Msg </span><span class="cov0" title="0">{
                                return messages.GotoMainPageMsg{}
                        }</span>
                }
        }

        // Обновление таблицы только если мы в состоянии списка
        <span class="cov0" title="0">if m.state == ViewerListState </span><span class="cov0" title="0">{
                m.table, cmd = m.table.Update(msg)
        }</span>

        <span class="cov0" title="0">return m, cmd</span>
}

// handleAddState - метод обработки окна добавления секретов
func (m ViewerModel) handleAddState(msg tea.Msg) (ViewerModel, tea.Cmd) <span class="cov0" title="0">{
        // Передаем сообщение в модель добавления
        updatedModel, cmd := m.addModel.Update(msg)
        m.addModel = updatedModel
        return m, cmd
}</span>

// handleViewState - метод обработки окна просмотра секретов
func (m ViewerModel) handleViewState(msg tea.Msg) (ViewerModel, tea.Cmd) <span class="cov0" title="0">{
        // ESC в окне просмотра - возврат к списку секретов
        if keyMsg, ok := msg.(tea.KeyMsg); ok &amp;&amp; keyMsg.String() == "esc" </span><span class="cov0" title="0">{
                m.state = ViewerListState
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// handleEnterAction - метод обработки нажатия на enter
func (m ViewerModel) handleEnterAction() (ViewerModel, tea.Cmd) <span class="cov0" title="0">{
        // Если выбрана кнопка "Добавить"
        if m.focusedBtn == AddButton </span><span class="cov0" title="0">{
                m.state = SecretAddState
                return m, m.addModel.Init()
        }</span>
        // Если выбрана кнопка "Обновить"
        <span class="cov0" title="0">if m.focusedBtn == UpdateButton </span><span class="cov0" title="0">{
                return m, m.attemptGetSecrets()
        }</span>

        <span class="cov0" title="0">if len(m.table.Rows()) == 0 </span><span class="cov0" title="0">{
                return m, nil
        }</span>
        <span class="cov0" title="0">selectedID := m.table.SelectedRow()[0]

        // Если выбрана кнопка "Просмотр" И есть выбранная строка
        if m.focusedBtn == ViewButton &amp;&amp; m.table.SelectedRow() != nil </span><span class="cov0" title="0">{
                m.state = SecretAddState
                return m, m.attemptGetSecret(selectedID)
        }</span>

        // Если выбрана кнопка "Удалить" и есть выбранная строка
        <span class="cov0" title="0">if m.focusedBtn == DeleteButton &amp;&amp; m.table.SelectedRow() != nil </span><span class="cov0" title="0">{
                return m, m.attemptDeleteSecret(selectedID)
        }</span>

        <span class="cov0" title="0">return m, nil</span>
}

// handleAuthAction - обработчик авторизации (формирование токена и ключа шифрования)
func (m ViewerModel) handleAuthAction(msg messages.AuthSuccessMsg) (ViewerModel, tea.Cmd) <span class="cov0" title="0">{
        m.token = msg.Token
        key, err := crypto.MakeCryptoKey(m.settings.Secret, msg.Salt)
        if err != nil </span><span class="cov0" title="0">{
                return m, func() tea.Msg </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка формирования ключа: %s", err.Error()))
                }</span>
        }
        <span class="cov0" title="0">m.cryptoKey = key
        return m, nil</span>
}

// refreshViewer - обновление таблицы секретов
func (m ViewerModel) refreshViewer() ViewerModel <span class="cov0" title="0">{
        m.table.SetRows(createTableRows(m.secrets))
        return m
}</span>

// View - метод отрисовки текущего состояния
func (m ViewerModel) View() string <span class="cov0" title="0">{
        switch m.state </span>{
        case ViewerListState:<span class="cov0" title="0">
                return m.renderViewerListView()</span>
        case SecretAddState:<span class="cov0" title="0">
                return m.addModel.View()</span>
        default:<span class="cov0" title="0">
                return "Неизвестное состояние"</span>
        }
}

// createTable - метод формирования модели таблицы секретов
func createTable() table.Model <span class="cov0" title="0">{
        columns := []table.Column{
                {Title: "ID", Width: 8},
                {Title: "Название", Width: 40},
                {Title: "Тип", Width: 10},
                {Title: "Создан", Width: 15},
                {Title: "Обновлен", Width: 15},
        }

        t := table.New(
                table.WithColumns(columns),
                table.WithFocused(true),
                table.WithHeight(10),
                table.WithWidth(100),
        )

        s := table.DefaultStyles()
        s.Header = styles.TableHeaderStyle.
                BorderStyle(lipgloss.NormalBorder()).
                BorderForeground(lipgloss.Color("240")).
                BorderBottom(true)

        s.Selected = styles.TableSelectedStyle.
                Foreground(lipgloss.Color("229")).
                Background(lipgloss.Color("57"))

        t.SetStyles(s)

        return t
}</span>

// createTableRows - метод формирования строк в таблице секретов
func createTableRows(secrets []*models.SecretInfo) []table.Row <span class="cov0" title="0">{
        rows := make([]table.Row, len(secrets))
        for i, secret := range secrets </span><span class="cov0" title="0">{
                rows[i] = table.Row{
                        secret.ID,
                        secret.Name,
                        secret.Type,
                        secret.Created.Local().Format(time.DateTime),
                        secret.Updated.Local().Format(time.DateTime),
                }
        }</span>
        <span class="cov0" title="0">return rows</span>
}

// renderViewerListView - метод отрисовки списка секретов
func (m ViewerModel) renderViewerListView() string <span class="cov0" title="0">{
        content := lipgloss.JoinVertical(
                lipgloss.Center,
                styles.TitleStyle.
                        Width(m.windowSize.Width-10).
                        Render("🔒 Управление секретами"),

                lipgloss.NewStyle().Height(2).Render(""),

                styles.TableStyle.
                        Width(m.table.Width()).
                        Render(m.table.View()),

                lipgloss.NewStyle().Height(2).Render(""),

                m.renderButtons(),

                lipgloss.NewStyle().Height(1).Render(""),

                m.renderHelpText(),
        )

        return styles.ContainerStyle.
                Width(m.windowSize.Width).
                Height(m.windowSize.Height).
                Render(
                        lipgloss.Place(
                                m.windowSize.Width, m.windowSize.Height,
                                lipgloss.Center, lipgloss.Center,
                                content,
                                lipgloss.WithWhitespaceChars(" "),
                                lipgloss.WithWhitespaceForeground(styles.BackgroundColor),
                        ),
                )
}</span>

// renderButtons - метод отрисовки кнопок
func (m ViewerModel) renderButtons() string <span class="cov0" title="0">{
        buttons := []string{
                m.renderButton("➕ Добавить", AddButton),
                m.renderButton("👁️ Просмотр", ViewButton),
                m.renderButton("🗑️ Удалить", DeleteButton),
                m.renderButton("🔄 Обновить", UpdateButton),
        }

        return lipgloss.JoinHorizontal(
                lipgloss.Center,
                buttons...,
        )
}</span>

// renderButtons - метод отрисовки кнопки
func (m ViewerModel) renderButton(text string, index int) string <span class="cov0" title="0">{
        if index == m.focusedBtn </span><span class="cov0" title="0">{
                return styles.ActiveButtonStyle.
                        Width(15).
                        Height(2).
                        Render(text)
        }</span>
        <span class="cov0" title="0">return styles.ButtonStyle.
                Width(15).
                Height(2).
                Render(text)</span>
}

// renderButtons - метод отрисовки вспомогательного текста
func (m ViewerModel) renderHelpText() string <span class="cov0" title="0">{
        helpText := "↑/↓: выбор секрета • ←/→: выбор кнопки • Enter: действие • R: обновить • ESC: выход"

        if m.table.SelectedRow() != nil </span><span class="cov0" title="0">{
                helpText += " • Выбрано: " + m.table.SelectedRow()[1]
        }</span>

        <span class="cov0" title="0">return lipgloss.NewStyle().
                Foreground(styles.TextSecondary).
                Italic(true).
                Render(helpText)</span>
}

// attemptGetSecrets - обработчик получения секретов
func (m ViewerModel) attemptGetSecrets() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), time.Duration(m.settings.Timeout)*time.Second)
                client := grpcclient.NewKeeperClient(m.settings.ServerAddress(), m.token)
                defer func() </span><span class="cov0" title="0">{
                        cancel()
                        client.Close()
                }</span>()
                <span class="cov0" title="0">if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка подключения к %s: %s", m.settings.ServerAddress(), err.Error()))
                }</span>
                <span class="cov0" title="0">secrets, err := client.GetSecrets()
                if err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка получения данных: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">return messages.SecretRefreshMsg{Secrets: secrets}</span>
        }
}

// attemptDeleteSecret - обработчик удаления секрета
func (m ViewerModel) attemptDeleteSecret(sid string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), time.Duration(m.settings.Timeout)*time.Second)
                client := grpcclient.NewKeeperClient(m.settings.ServerAddress(), m.token)
                defer func() </span><span class="cov0" title="0">{
                        cancel()
                        client.Close()
                }</span>()
                <span class="cov0" title="0">if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка подключения к %s: %s", m.settings.ServerAddress(), err.Error()))
                }</span>
                <span class="cov0" title="0">id, err := client.DeleteSecret(sid)
                if err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка удаления секрета: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">return messages.SecretDeleteMsg{Id: id}</span>
        }
}

// attemptAddSecret - обработчик добавления секрета
func (m ViewerModel) attemptAddSecret(converter messages.EncryptConverter) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                info, content, err := converter.ToModel(m.cryptoKey)
                if err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка добавления секрета: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), time.Duration(m.settings.Timeout)*time.Second)
                client := grpcclient.NewKeeperClient(m.settings.ServerAddress(), m.token)
                defer func() </span><span class="cov0" title="0">{
                        cancel()
                        client.Close()
                }</span>()
                <span class="cov0" title="0">if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка подключения к %s: %s", m.settings.ServerAddress(), err.Error()))
                }</span>
                <span class="cov0" title="0">_, err = client.AddSecret(info, content)
                if err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка добавления секрета: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">return messages.SecretUpdateMsg{}</span>
        }
}

// attemptEditSecret - обработчик изменения секрета
func (m ViewerModel) attemptEditSecret(converter messages.EncryptConverter) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                info, content, err := converter.ToModel(m.cryptoKey)
                if err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка изменения секрета: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), time.Duration(m.settings.Timeout)*time.Second)
                client := grpcclient.NewKeeperClient(m.settings.ServerAddress(), m.token)
                defer func() </span><span class="cov0" title="0">{
                        cancel()
                        client.Close()
                }</span>()
                <span class="cov0" title="0">if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка подключения к %s: %s", m.settings.ServerAddress(), err.Error()))
                }</span>
                <span class="cov0" title="0">_, err = client.EditSecret(info, content)
                if err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка изменения секрета: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">return messages.SecretUpdateMsg{}</span>
        }
}

// attemptGetSecret - обработчик получения секрета
func (m ViewerModel) attemptGetSecret(sid string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), time.Duration(m.settings.Timeout)*time.Second)
                client := grpcclient.NewKeeperClient(m.settings.ServerAddress(), m.token)
                defer func() </span><span class="cov0" title="0">{
                        cancel()
                        client.Close()
                }</span>()
                <span class="cov0" title="0">if err := client.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка подключения к %s: %s", m.settings.ServerAddress(), err.Error()))
                }</span>
                <span class="cov0" title="0">info, content, err := client.GetSecret(sid)
                if err != nil </span><span class="cov0" title="0">{
                        return messages.ErrorMsg(fmt.Sprintf("Ошибка добавления секрета: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">return messages.ToMessage(m.cryptoKey, info, content)</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package crypto

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "io"

        "golang.org/x/crypto/scrypt"
)

const (
        scryptN      = 32768 // Параметр стоимости CPU (итерации)
        scryptR      = 8     // Параметр размера блока
        scryptP      = 1     // Параметр параллелизма
        scryptKeyLen = 32    // Длина ключа
)

// GenerateSalt - метод генерирует криптографически безопасную случайную соль длинной 16 байт .
func GenerateSalt() (string, error) <span class="cov8" title="1">{
        salt := make([]byte, 16)
        if _, err := rand.Read(salt); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate salt: %w", err)
        }</span>
        <span class="cov8" title="1">return base64.StdEncoding.EncodeToString(salt), nil</span>
}

// MakeCryptoKey - метод формирует ключ из пароля и соли
func MakeCryptoKey(password string, salt string) ([]byte, error) <span class="cov8" title="1">{
        saltBytes, err := base64.StdEncoding.DecodeString(salt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode salt: %w", err)
        }</span>

        <span class="cov8" title="1">key, err := scrypt.Key([]byte(password), saltBytes, scryptN, scryptR, scryptP, scryptKeyLen)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to derive key: %w", err)
        }</span>

        <span class="cov8" title="1">return key, nil</span>
}

// Encrypt - метод шифрует данные используя ключ на основе пароля и соли
func Encrypt(key []byte, data []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("aes.NewCipher failed: %w", err)
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cipher.NewGCM failed: %w", err)
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nonce generation failed: %w", err)
        }</span>

        <span class="cov8" title="1">ciphertext := gcm.Seal(nil, nonce, data, nil)

        // Формируем итоговый результат: nonce + ciphertext (включая tag)
        result := make([]byte, len(nonce)+len(ciphertext))
        copy(result[:len(nonce)], nonce)
        copy(result[len(nonce):], ciphertext)

        return result, nil</span>
}

// Decrypt - метод расшифровывает данные используя ключ на основе пароля и соли
func Decrypt(key []byte, data []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("aes.NewCipher failed: %w", err)
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cipher.NewGCM failed: %w", err)
        }</span>

        <span class="cov8" title="1">nonceSize := gcm.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("encrypted data too short")
        }</span>

        // Извлекаем nonce и ciphertext (который включает tag)
        <span class="cov8" title="1">nonce := data[:nonceSize]
        ciphertext := data[nonceSize:]

        plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("decryption failed: %w", err)
        }</span>

        <span class="cov8" title="1">return plaintext, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package logger

import (
        "sync"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

var (
        once     sync.Once
        instance *zap.SugaredLogger = nil
)

// Initialize - инициализирует синглтон логера с необходимым уровнем логирования.
func Initialize(level string) error <span class="cov0" title="0">{
        var initErr error
        once.Do(func() </span><span class="cov0" title="0">{
                // преобразуем текстовый уровень логирования в zap.AtomicLevel
                lvl, err := zap.ParseAtomicLevel(level)
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>
                // создаём новую конфигурацию логера
                <span class="cov0" title="0">cfg := zap.NewProductionConfig()
                // устанавливаем уровень
                cfg.Level = lvl
                cfg.EncoderConfig.TimeKey = "time"
                cfg.EncoderConfig.EncodeTime = zapcore.TimeEncoderOfLayout("2006-01-02 15:04:05")
                // создаём логер на основе конфигурации
                logger, err := cfg.Build()
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>
                // устанавливаем синглтон
                <span class="cov0" title="0">instance = logger.Sugar()</span>
        })
        <span class="cov0" title="0">return initErr</span>
}

// Get - метод получения объекта логгера из синглтона
func Get() *zap.SugaredLogger <span class="cov0" title="0">{
        if instance == nil </span><span class="cov0" title="0">{
                // Возвращаем no-op логгер вместо паники
                return zap.NewNop().Sugar()
        }</span>
        <span class="cov0" title="0">return instance</span>
}

// Sync - метод синхронизации буфферов
func Sync() error <span class="cov0" title="0">{
        if instance != nil </span><span class="cov0" title="0">{
                return instance.Sync()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Debug — обертка над методом логирования уровня Debug
func Debug(args ...interface{}) <span class="cov0" title="0">{
        Get().Debugln(args...)
}</span>

// Info — обертка над методом логирования уровня Info
func Info(args ...interface{}) <span class="cov0" title="0">{
        Get().Infoln(args...)
}</span>

// Warn — обертка над методом логирования уровня Warn
func Warn(args ...interface{}) <span class="cov0" title="0">{
        Get().Warnln(args...)
}</span>

// Error — обертка над методом логирования уровня Error
func Error(args ...interface{}) <span class="cov0" title="0">{
        Get().Errorln(args...)
}</span>

// Panic — обертка над методом логирования уровня Panic
func Panic(args ...interface{}) <span class="cov0" title="0">{
        Get().Panicln(args...)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.8
//         protoc        v6.32.0
// source: api/keeper.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SecretMetadata struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Type          string                 `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
        Created       *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=created,proto3,oneof" json:"created,omitempty"`
        Updated       *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=updated,proto3,oneof" json:"updated,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SecretMetadata) Reset() <span class="cov0" title="0">{
        *x = SecretMetadata{}
        mi := &amp;file_api_keeper_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SecretMetadata) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecretMetadata) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecretMetadata) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SecretMetadata.ProtoReflect.Descriptor instead.
func (*SecretMetadata) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{0}
}</span>

func (x *SecretMetadata) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecretMetadata) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecretMetadata) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecretMetadata) GetCreated() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Created
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecretMetadata) GetUpdated() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Updated
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetSecretsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetSecretsRequest) Reset() <span class="cov0" title="0">{
        *x = GetSecretsRequest{}
        mi := &amp;file_api_keeper_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSecretsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSecretsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSecretsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSecretsRequest.ProtoReflect.Descriptor instead.
func (*GetSecretsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{1}
}</span>

type GetSecretsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Secrets       []*SecretMetadata      `protobuf:"bytes,1,rep,name=secrets,proto3" json:"secrets,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetSecretsResponse) Reset() <span class="cov0" title="0">{
        *x = GetSecretsResponse{}
        mi := &amp;file_api_keeper_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSecretsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSecretsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSecretsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSecretsResponse.ProtoReflect.Descriptor instead.
func (*GetSecretsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetSecretsResponse) GetSecrets() []*SecretMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Secrets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddSecretRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Meta          *SecretMetadata        `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
        Content       []byte                 `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AddSecretRequest) Reset() <span class="cov0" title="0">{
        *x = AddSecretRequest{}
        mi := &amp;file_api_keeper_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddSecretRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddSecretRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddSecretRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddSecretRequest.ProtoReflect.Descriptor instead.
func (*AddSecretRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{3}
}</span>

func (x *AddSecretRequest) GetMeta() *SecretMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AddSecretRequest) GetContent() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddSecretResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Meta          *SecretMetadata        `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AddSecretResponse) Reset() <span class="cov0" title="0">{
        *x = AddSecretResponse{}
        mi := &amp;file_api_keeper_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddSecretResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddSecretResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddSecretResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddSecretResponse.ProtoReflect.Descriptor instead.
func (*AddSecretResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{4}
}</span>

func (x *AddSecretResponse) GetMeta() *SecretMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetSecretRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Meta          *SecretMetadata        `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetSecretRequest) Reset() <span class="cov0" title="0">{
        *x = GetSecretRequest{}
        mi := &amp;file_api_keeper_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSecretRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSecretRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSecretRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSecretRequest.ProtoReflect.Descriptor instead.
func (*GetSecretRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetSecretRequest) GetMeta() *SecretMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetSecretResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Meta          *SecretMetadata        `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
        Content       []byte                 `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetSecretResponse) Reset() <span class="cov0" title="0">{
        *x = GetSecretResponse{}
        mi := &amp;file_api_keeper_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSecretResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSecretResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSecretResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSecretResponse.ProtoReflect.Descriptor instead.
func (*GetSecretResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetSecretResponse) GetMeta() *SecretMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetSecretResponse) GetContent() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteSecretRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Meta          *SecretMetadata        `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteSecretRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteSecretRequest{}
        mi := &amp;file_api_keeper_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteSecretRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteSecretRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteSecretRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteSecretRequest.ProtoReflect.Descriptor instead.
func (*DeleteSecretRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{7}
}</span>

func (x *DeleteSecretRequest) GetMeta() *SecretMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteSecretResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Meta          *SecretMetadata        `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteSecretResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteSecretResponse{}
        mi := &amp;file_api_keeper_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteSecretResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteSecretResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteSecretResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteSecretResponse.ProtoReflect.Descriptor instead.
func (*DeleteSecretResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{8}
}</span>

func (x *DeleteSecretResponse) GetMeta() *SecretMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type EditSecretRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Meta          *SecretMetadata        `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
        Content       []byte                 `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *EditSecretRequest) Reset() <span class="cov0" title="0">{
        *x = EditSecretRequest{}
        mi := &amp;file_api_keeper_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EditSecretRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EditSecretRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EditSecretRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EditSecretRequest.ProtoReflect.Descriptor instead.
func (*EditSecretRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{9}
}</span>

func (x *EditSecretRequest) GetMeta() *SecretMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *EditSecretRequest) GetContent() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type EditSecretResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Meta          *SecretMetadata        `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *EditSecretResponse) Reset() <span class="cov0" title="0">{
        *x = EditSecretResponse{}
        mi := &amp;file_api_keeper_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EditSecretResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EditSecretResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EditSecretResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_keeper_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EditSecretResponse.ProtoReflect.Descriptor instead.
func (*EditSecretResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_keeper_proto_rawDescGZIP(), []int{10}
}</span>

func (x *EditSecretResponse) GetMeta() *SecretMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_api_keeper_proto protoreflect.FileDescriptor

const file_api_keeper_proto_rawDesc = "" +
        "\n" +
        "\x10api/keeper.proto\x12\x03api\x1a\x1fgoogle/protobuf/timestamp.proto\"\xd6\x01\n" +
        "\x0eSecretMetadata\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04name\x18\x02 \x01(\tR\x04name\x12\x12\n" +
        "\x04type\x18\x03 \x01(\tR\x04type\x129\n" +
        "\acreated\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampH\x00R\acreated\x88\x01\x01\x129\n" +
        "\aupdated\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampH\x01R\aupdated\x88\x01\x01B\n" +
        "\n" +
        "\b_createdB\n" +
        "\n" +
        "\b_updated\"\x13\n" +
        "\x11GetSecretsRequest\"C\n" +
        "\x12GetSecretsResponse\x12-\n" +
        "\asecrets\x18\x01 \x03(\v2\x13.api.SecretMetadataR\asecrets\"U\n" +
        "\x10AddSecretRequest\x12'\n" +
        "\x04meta\x18\x01 \x01(\v2\x13.api.SecretMetadataR\x04meta\x12\x18\n" +
        "\acontent\x18\x02 \x01(\fR\acontent\"&lt;\n" +
        "\x11AddSecretResponse\x12'\n" +
        "\x04meta\x18\x01 \x01(\v2\x13.api.SecretMetadataR\x04meta\";\n" +
        "\x10GetSecretRequest\x12'\n" +
        "\x04meta\x18\x01 \x01(\v2\x13.api.SecretMetadataR\x04meta\"V\n" +
        "\x11GetSecretResponse\x12'\n" +
        "\x04meta\x18\x01 \x01(\v2\x13.api.SecretMetadataR\x04meta\x12\x18\n" +
        "\acontent\x18\x02 \x01(\fR\acontent\"&gt;\n" +
        "\x13DeleteSecretRequest\x12'\n" +
        "\x04meta\x18\x01 \x01(\v2\x13.api.SecretMetadataR\x04meta\"?\n" +
        "\x14DeleteSecretResponse\x12'\n" +
        "\x04meta\x18\x01 \x01(\v2\x13.api.SecretMetadataR\x04meta\"V\n" +
        "\x11EditSecretRequest\x12'\n" +
        "\x04meta\x18\x01 \x01(\v2\x13.api.SecretMetadataR\x04meta\x12\x18\n" +
        "\acontent\x18\x02 \x01(\fR\acontent\"=\n" +
        "\x12EditSecretResponse\x12'\n" +
        "\x04meta\x18\x01 \x01(\v2\x13.api.SecretMetadataR\x04meta2\xc3\x02\n" +
        "\x06Keeper\x12=\n" +
        "\n" +
        "GetSecrets\x12\x16.api.GetSecretsRequest\x1a\x17.api.GetSecretsResponse\x12:\n" +
        "\tAddSecret\x12\x15.api.AddSecretRequest\x1a\x16.api.AddSecretResponse\x12:\n" +
        "\tGetSecret\x12\x15.api.GetSecretRequest\x1a\x16.api.GetSecretResponse\x12C\n" +
        "\fDeleteSecret\x12\x18.api.DeleteSecretRequest\x1a\x19.api.DeleteSecretResponse\x12=\n" +
        "\n" +
        "EditSecret\x12\x16.api.EditSecretRequest\x1a\x17.api.EditSecretResponseB\vZ\tpkg/protob\x06proto3"

var (
        file_api_keeper_proto_rawDescOnce sync.Once
        file_api_keeper_proto_rawDescData []byte
)

func file_api_keeper_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_keeper_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_keeper_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_keeper_proto_rawDesc), len(file_api_keeper_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_api_keeper_proto_rawDescData</span>
}

var file_api_keeper_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_api_keeper_proto_goTypes = []any{
        (*SecretMetadata)(nil),        // 0: api.SecretMetadata
        (*GetSecretsRequest)(nil),     // 1: api.GetSecretsRequest
        (*GetSecretsResponse)(nil),    // 2: api.GetSecretsResponse
        (*AddSecretRequest)(nil),      // 3: api.AddSecretRequest
        (*AddSecretResponse)(nil),     // 4: api.AddSecretResponse
        (*GetSecretRequest)(nil),      // 5: api.GetSecretRequest
        (*GetSecretResponse)(nil),     // 6: api.GetSecretResponse
        (*DeleteSecretRequest)(nil),   // 7: api.DeleteSecretRequest
        (*DeleteSecretResponse)(nil),  // 8: api.DeleteSecretResponse
        (*EditSecretRequest)(nil),     // 9: api.EditSecretRequest
        (*EditSecretResponse)(nil),    // 10: api.EditSecretResponse
        (*timestamppb.Timestamp)(nil), // 11: google.protobuf.Timestamp
}
var file_api_keeper_proto_depIdxs = []int32{
        11, // 0: api.SecretMetadata.created:type_name -&gt; google.protobuf.Timestamp
        11, // 1: api.SecretMetadata.updated:type_name -&gt; google.protobuf.Timestamp
        0,  // 2: api.GetSecretsResponse.secrets:type_name -&gt; api.SecretMetadata
        0,  // 3: api.AddSecretRequest.meta:type_name -&gt; api.SecretMetadata
        0,  // 4: api.AddSecretResponse.meta:type_name -&gt; api.SecretMetadata
        0,  // 5: api.GetSecretRequest.meta:type_name -&gt; api.SecretMetadata
        0,  // 6: api.GetSecretResponse.meta:type_name -&gt; api.SecretMetadata
        0,  // 7: api.DeleteSecretRequest.meta:type_name -&gt; api.SecretMetadata
        0,  // 8: api.DeleteSecretResponse.meta:type_name -&gt; api.SecretMetadata
        0,  // 9: api.EditSecretRequest.meta:type_name -&gt; api.SecretMetadata
        0,  // 10: api.EditSecretResponse.meta:type_name -&gt; api.SecretMetadata
        1,  // 11: api.Keeper.GetSecrets:input_type -&gt; api.GetSecretsRequest
        3,  // 12: api.Keeper.AddSecret:input_type -&gt; api.AddSecretRequest
        5,  // 13: api.Keeper.GetSecret:input_type -&gt; api.GetSecretRequest
        7,  // 14: api.Keeper.DeleteSecret:input_type -&gt; api.DeleteSecretRequest
        9,  // 15: api.Keeper.EditSecret:input_type -&gt; api.EditSecretRequest
        2,  // 16: api.Keeper.GetSecrets:output_type -&gt; api.GetSecretsResponse
        4,  // 17: api.Keeper.AddSecret:output_type -&gt; api.AddSecretResponse
        6,  // 18: api.Keeper.GetSecret:output_type -&gt; api.GetSecretResponse
        8,  // 19: api.Keeper.DeleteSecret:output_type -&gt; api.DeleteSecretResponse
        10, // 20: api.Keeper.EditSecret:output_type -&gt; api.EditSecretResponse
        16, // [16:21] is the sub-list for method output_type
        11, // [11:16] is the sub-list for method input_type
        11, // [11:11] is the sub-list for extension type_name
        11, // [11:11] is the sub-list for extension extendee
        0,  // [0:11] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_api_keeper_proto_init() }</span>
func file_api_keeper_proto_init() <span class="cov0" title="0">{
        if File_api_keeper_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_api_keeper_proto_msgTypes[0].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_keeper_proto_rawDesc), len(file_api_keeper_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   11,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_keeper_proto_goTypes,
                DependencyIndexes: file_api_keeper_proto_depIdxs,
                MessageInfos:      file_api_keeper_proto_msgTypes,
        }.Build()
        File_api_keeper_proto = out.File
        file_api_keeper_proto_goTypes = nil
        file_api_keeper_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: api/keeper.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Keeper_GetSecrets_FullMethodName   = "/api.Keeper/GetSecrets"
        Keeper_AddSecret_FullMethodName    = "/api.Keeper/AddSecret"
        Keeper_GetSecret_FullMethodName    = "/api.Keeper/GetSecret"
        Keeper_DeleteSecret_FullMethodName = "/api.Keeper/DeleteSecret"
        Keeper_EditSecret_FullMethodName   = "/api.Keeper/EditSecret"
)

// KeeperClient is the client API for Keeper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeeperClient interface {
        GetSecrets(ctx context.Context, in *GetSecretsRequest, opts ...grpc.CallOption) (*GetSecretsResponse, error)
        AddSecret(ctx context.Context, in *AddSecretRequest, opts ...grpc.CallOption) (*AddSecretResponse, error)
        GetSecret(ctx context.Context, in *GetSecretRequest, opts ...grpc.CallOption) (*GetSecretResponse, error)
        DeleteSecret(ctx context.Context, in *DeleteSecretRequest, opts ...grpc.CallOption) (*DeleteSecretResponse, error)
        EditSecret(ctx context.Context, in *EditSecretRequest, opts ...grpc.CallOption) (*EditSecretResponse, error)
}

type keeperClient struct {
        cc grpc.ClientConnInterface
}

func NewKeeperClient(cc grpc.ClientConnInterface) KeeperClient <span class="cov0" title="0">{
        return &amp;keeperClient{cc}
}</span>

func (c *keeperClient) GetSecrets(ctx context.Context, in *GetSecretsRequest, opts ...grpc.CallOption) (*GetSecretsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetSecretsResponse)
        err := c.cc.Invoke(ctx, Keeper_GetSecrets_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperClient) AddSecret(ctx context.Context, in *AddSecretRequest, opts ...grpc.CallOption) (*AddSecretResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AddSecretResponse)
        err := c.cc.Invoke(ctx, Keeper_AddSecret_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperClient) GetSecret(ctx context.Context, in *GetSecretRequest, opts ...grpc.CallOption) (*GetSecretResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetSecretResponse)
        err := c.cc.Invoke(ctx, Keeper_GetSecret_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperClient) DeleteSecret(ctx context.Context, in *DeleteSecretRequest, opts ...grpc.CallOption) (*DeleteSecretResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteSecretResponse)
        err := c.cc.Invoke(ctx, Keeper_DeleteSecret_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *keeperClient) EditSecret(ctx context.Context, in *EditSecretRequest, opts ...grpc.CallOption) (*EditSecretResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EditSecretResponse)
        err := c.cc.Invoke(ctx, Keeper_EditSecret_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// KeeperServer is the server API for Keeper service.
// All implementations must embed UnimplementedKeeperServer
// for forward compatibility.
type KeeperServer interface {
        GetSecrets(context.Context, *GetSecretsRequest) (*GetSecretsResponse, error)
        AddSecret(context.Context, *AddSecretRequest) (*AddSecretResponse, error)
        GetSecret(context.Context, *GetSecretRequest) (*GetSecretResponse, error)
        DeleteSecret(context.Context, *DeleteSecretRequest) (*DeleteSecretResponse, error)
        EditSecret(context.Context, *EditSecretRequest) (*EditSecretResponse, error)
        mustEmbedUnimplementedKeeperServer()
}

// UnimplementedKeeperServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKeeperServer struct{}

func (UnimplementedKeeperServer) GetSecrets(context.Context, *GetSecretsRequest) (*GetSecretsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSecrets not implemented")
}</span>
func (UnimplementedKeeperServer) AddSecret(context.Context, *AddSecretRequest) (*AddSecretResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddSecret not implemented")
}</span>
func (UnimplementedKeeperServer) GetSecret(context.Context, *GetSecretRequest) (*GetSecretResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSecret not implemented")
}</span>
func (UnimplementedKeeperServer) DeleteSecret(context.Context, *DeleteSecretRequest) (*DeleteSecretResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteSecret not implemented")
}</span>
func (UnimplementedKeeperServer) EditSecret(context.Context, *EditSecretRequest) (*EditSecretResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method EditSecret not implemented")
}</span>
func (UnimplementedKeeperServer) mustEmbedUnimplementedKeeperServer() {<span class="cov0" title="0">}</span>
func (UnimplementedKeeperServer) testEmbeddedByValue()                {<span class="cov0" title="0">}</span>

// UnsafeKeeperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeeperServer will
// result in compilation errors.
type UnsafeKeeperServer interface {
        mustEmbedUnimplementedKeeperServer()
}

func RegisterKeeperServer(s grpc.ServiceRegistrar, srv KeeperServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedKeeperServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Keeper_ServiceDesc, srv)</span>
}

func _Keeper_GetSecrets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSecretsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServer).GetSecrets(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Keeper_GetSecrets_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServer).GetSecrets(ctx, req.(*GetSecretsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Keeper_AddSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddSecretRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServer).AddSecret(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Keeper_AddSecret_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServer).AddSecret(ctx, req.(*AddSecretRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Keeper_GetSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSecretRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServer).GetSecret(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Keeper_GetSecret_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServer).GetSecret(ctx, req.(*GetSecretRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Keeper_DeleteSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteSecretRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServer).DeleteSecret(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Keeper_DeleteSecret_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServer).DeleteSecret(ctx, req.(*DeleteSecretRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Keeper_EditSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(EditSecretRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KeeperServer).EditSecret(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Keeper_EditSecret_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KeeperServer).EditSecret(ctx, req.(*EditSecretRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Keeper_ServiceDesc is the grpc.ServiceDesc for Keeper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Keeper_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "api.Keeper",
        HandlerType: (*KeeperServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetSecrets",
                        Handler:    _Keeper_GetSecrets_Handler,
                },
                {
                        MethodName: "AddSecret",
                        Handler:    _Keeper_AddSecret_Handler,
                },
                {
                        MethodName: "GetSecret",
                        Handler:    _Keeper_GetSecret_Handler,
                },
                {
                        MethodName: "DeleteSecret",
                        Handler:    _Keeper_DeleteSecret_Handler,
                },
                {
                        MethodName: "EditSecret",
                        Handler:    _Keeper_EditSecret_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api/keeper.proto",
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg\proto\keeper_grpc.pb.go
//
// Generated by this command:
//
//        mockgen -source=pkg\proto\keeper_grpc.pb.go -destination=pkg\proto\mocks\keeper_grpc.pb_mock.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        proto "go-pass-keeper/pkg/proto"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
        grpc "google.golang.org/grpc"
)

// MockKeeperClient is a mock of KeeperClient interface.
type MockKeeperClient struct {
        ctrl     *gomock.Controller
        recorder *MockKeeperClientMockRecorder
        isgomock struct{}
}

// MockKeeperClientMockRecorder is the mock recorder for MockKeeperClient.
type MockKeeperClientMockRecorder struct {
        mock *MockKeeperClient
}

// NewMockKeeperClient creates a new mock instance.
func NewMockKeeperClient(ctrl *gomock.Controller) *MockKeeperClient <span class="cov0" title="0">{
        mock := &amp;MockKeeperClient{ctrl: ctrl}
        mock.recorder = &amp;MockKeeperClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockKeeperClient) EXPECT() *MockKeeperClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddSecret mocks base method.
func (m *MockKeeperClient) AddSecret(ctx context.Context, in *proto.AddSecretRequest, opts ...grpc.CallOption) (*proto.AddSecretResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "AddSecret", varargs...)
        ret0, _ := ret[0].(*proto.AddSecretResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// AddSecret indicates an expected call of AddSecret.
func (mr *MockKeeperClientMockRecorder) AddSecret(ctx, in any, opts ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSecret", reflect.TypeOf((*MockKeeperClient)(nil).AddSecret), varargs...)
}</span>

// DeleteSecret mocks base method.
func (m *MockKeeperClient) DeleteSecret(ctx context.Context, in *proto.DeleteSecretRequest, opts ...grpc.CallOption) (*proto.DeleteSecretResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "DeleteSecret", varargs...)
        ret0, _ := ret[0].(*proto.DeleteSecretResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteSecret indicates an expected call of DeleteSecret.
func (mr *MockKeeperClientMockRecorder) DeleteSecret(ctx, in any, opts ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSecret", reflect.TypeOf((*MockKeeperClient)(nil).DeleteSecret), varargs...)
}</span>

// EditSecret mocks base method.
func (m *MockKeeperClient) EditSecret(ctx context.Context, in *proto.EditSecretRequest, opts ...grpc.CallOption) (*proto.EditSecretResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "EditSecret", varargs...)
        ret0, _ := ret[0].(*proto.EditSecretResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// EditSecret indicates an expected call of EditSecret.
func (mr *MockKeeperClientMockRecorder) EditSecret(ctx, in any, opts ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EditSecret", reflect.TypeOf((*MockKeeperClient)(nil).EditSecret), varargs...)
}</span>

// GetSecret mocks base method.
func (m *MockKeeperClient) GetSecret(ctx context.Context, in *proto.GetSecretRequest, opts ...grpc.CallOption) (*proto.GetSecretResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetSecret", varargs...)
        ret0, _ := ret[0].(*proto.GetSecretResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetSecret indicates an expected call of GetSecret.
func (mr *MockKeeperClientMockRecorder) GetSecret(ctx, in any, opts ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSecret", reflect.TypeOf((*MockKeeperClient)(nil).GetSecret), varargs...)
}</span>

// GetSecrets mocks base method.
func (m *MockKeeperClient) GetSecrets(ctx context.Context, in *proto.GetSecretsRequest, opts ...grpc.CallOption) (*proto.GetSecretsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetSecrets", varargs...)
        ret0, _ := ret[0].(*proto.GetSecretsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetSecrets indicates an expected call of GetSecrets.
func (mr *MockKeeperClientMockRecorder) GetSecrets(ctx, in any, opts ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSecrets", reflect.TypeOf((*MockKeeperClient)(nil).GetSecrets), varargs...)
}</span>

// MockKeeperServer is a mock of KeeperServer interface.
type MockKeeperServer struct {
        ctrl     *gomock.Controller
        recorder *MockKeeperServerMockRecorder
        isgomock struct{}
}

// MockKeeperServerMockRecorder is the mock recorder for MockKeeperServer.
type MockKeeperServerMockRecorder struct {
        mock *MockKeeperServer
}

// NewMockKeeperServer creates a new mock instance.
func NewMockKeeperServer(ctrl *gomock.Controller) *MockKeeperServer <span class="cov0" title="0">{
        mock := &amp;MockKeeperServer{ctrl: ctrl}
        mock.recorder = &amp;MockKeeperServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockKeeperServer) EXPECT() *MockKeeperServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddSecret mocks base method.
func (m *MockKeeperServer) AddSecret(arg0 context.Context, arg1 *proto.AddSecretRequest) (*proto.AddSecretResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddSecret", arg0, arg1)
        ret0, _ := ret[0].(*proto.AddSecretResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddSecret indicates an expected call of AddSecret.
func (mr *MockKeeperServerMockRecorder) AddSecret(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSecret", reflect.TypeOf((*MockKeeperServer)(nil).AddSecret), arg0, arg1)
}</span>

// DeleteSecret mocks base method.
func (m *MockKeeperServer) DeleteSecret(arg0 context.Context, arg1 *proto.DeleteSecretRequest) (*proto.DeleteSecretResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteSecret", arg0, arg1)
        ret0, _ := ret[0].(*proto.DeleteSecretResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteSecret indicates an expected call of DeleteSecret.
func (mr *MockKeeperServerMockRecorder) DeleteSecret(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSecret", reflect.TypeOf((*MockKeeperServer)(nil).DeleteSecret), arg0, arg1)
}</span>

// EditSecret mocks base method.
func (m *MockKeeperServer) EditSecret(arg0 context.Context, arg1 *proto.EditSecretRequest) (*proto.EditSecretResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "EditSecret", arg0, arg1)
        ret0, _ := ret[0].(*proto.EditSecretResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// EditSecret indicates an expected call of EditSecret.
func (mr *MockKeeperServerMockRecorder) EditSecret(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EditSecret", reflect.TypeOf((*MockKeeperServer)(nil).EditSecret), arg0, arg1)
}</span>

// GetSecret mocks base method.
func (m *MockKeeperServer) GetSecret(arg0 context.Context, arg1 *proto.GetSecretRequest) (*proto.GetSecretResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSecret", arg0, arg1)
        ret0, _ := ret[0].(*proto.GetSecretResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSecret indicates an expected call of GetSecret.
func (mr *MockKeeperServerMockRecorder) GetSecret(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSecret", reflect.TypeOf((*MockKeeperServer)(nil).GetSecret), arg0, arg1)
}</span>

// GetSecrets mocks base method.
func (m *MockKeeperServer) GetSecrets(arg0 context.Context, arg1 *proto.GetSecretsRequest) (*proto.GetSecretsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSecrets", arg0, arg1)
        ret0, _ := ret[0].(*proto.GetSecretsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSecrets indicates an expected call of GetSecrets.
func (mr *MockKeeperServerMockRecorder) GetSecrets(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSecrets", reflect.TypeOf((*MockKeeperServer)(nil).GetSecrets), arg0, arg1)
}</span>

// mustEmbedUnimplementedKeeperServer mocks base method.
func (m *MockKeeperServer) mustEmbedUnimplementedKeeperServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedKeeperServer")
}</span>

// mustEmbedUnimplementedKeeperServer indicates an expected call of mustEmbedUnimplementedKeeperServer.
func (mr *MockKeeperServerMockRecorder) mustEmbedUnimplementedKeeperServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedKeeperServer", reflect.TypeOf((*MockKeeperServer)(nil).mustEmbedUnimplementedKeeperServer))
}</span>

// MockUnsafeKeeperServer is a mock of UnsafeKeeperServer interface.
type MockUnsafeKeeperServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeKeeperServerMockRecorder
        isgomock struct{}
}

// MockUnsafeKeeperServerMockRecorder is the mock recorder for MockUnsafeKeeperServer.
type MockUnsafeKeeperServerMockRecorder struct {
        mock *MockUnsafeKeeperServer
}

// NewMockUnsafeKeeperServer creates a new mock instance.
func NewMockUnsafeKeeperServer(ctrl *gomock.Controller) *MockUnsafeKeeperServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeKeeperServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeKeeperServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeKeeperServer) EXPECT() *MockUnsafeKeeperServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedKeeperServer mocks base method.
func (m *MockUnsafeKeeperServer) mustEmbedUnimplementedKeeperServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedKeeperServer")
}</span>

// mustEmbedUnimplementedKeeperServer indicates an expected call of mustEmbedUnimplementedKeeperServer.
func (mr *MockUnsafeKeeperServerMockRecorder) mustEmbedUnimplementedKeeperServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedKeeperServer", reflect.TypeOf((*MockUnsafeKeeperServer)(nil).mustEmbedUnimplementedKeeperServer))
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg\proto\user_grpc.pb.go
//
// Generated by this command:
//
//        mockgen -source=pkg\proto\user_grpc.pb.go -destination=pkg\proto\mocks\user_grpc.pb_mock.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        proto "go-pass-keeper/pkg/proto"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
        grpc "google.golang.org/grpc"
)

// MockUserClient is a mock of UserClient interface.
type MockUserClient struct {
        ctrl     *gomock.Controller
        recorder *MockUserClientMockRecorder
        isgomock struct{}
}

// MockUserClientMockRecorder is the mock recorder for MockUserClient.
type MockUserClientMockRecorder struct {
        mock *MockUserClient
}

// NewMockUserClient creates a new mock instance.
func NewMockUserClient(ctrl *gomock.Controller) *MockUserClient <span class="cov0" title="0">{
        mock := &amp;MockUserClient{ctrl: ctrl}
        mock.recorder = &amp;MockUserClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserClient) EXPECT() *MockUserClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Login mocks base method.
func (m *MockUserClient) Login(ctx context.Context, in *proto.LoginRequest, opts ...grpc.CallOption) (*proto.LoginResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Login", varargs...)
        ret0, _ := ret[0].(*proto.LoginResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Login indicates an expected call of Login.
func (mr *MockUserClientMockRecorder) Login(ctx, in any, opts ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockUserClient)(nil).Login), varargs...)
}</span>

// Register mocks base method.
func (m *MockUserClient) Register(ctx context.Context, in *proto.RegisterRequest, opts ...grpc.CallOption) (*proto.RegisterResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Register", varargs...)
        ret0, _ := ret[0].(*proto.RegisterResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Register indicates an expected call of Register.
func (mr *MockUserClientMockRecorder) Register(ctx, in any, opts ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockUserClient)(nil).Register), varargs...)
}</span>

// MockUserServer is a mock of UserServer interface.
type MockUserServer struct {
        ctrl     *gomock.Controller
        recorder *MockUserServerMockRecorder
        isgomock struct{}
}

// MockUserServerMockRecorder is the mock recorder for MockUserServer.
type MockUserServerMockRecorder struct {
        mock *MockUserServer
}

// NewMockUserServer creates a new mock instance.
func NewMockUserServer(ctrl *gomock.Controller) *MockUserServer <span class="cov0" title="0">{
        mock := &amp;MockUserServer{ctrl: ctrl}
        mock.recorder = &amp;MockUserServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserServer) EXPECT() *MockUserServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Login mocks base method.
func (m *MockUserServer) Login(arg0 context.Context, arg1 *proto.LoginRequest) (*proto.LoginResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Login", arg0, arg1)
        ret0, _ := ret[0].(*proto.LoginResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Login indicates an expected call of Login.
func (mr *MockUserServerMockRecorder) Login(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockUserServer)(nil).Login), arg0, arg1)
}</span>

// Register mocks base method.
func (m *MockUserServer) Register(arg0 context.Context, arg1 *proto.RegisterRequest) (*proto.RegisterResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Register", arg0, arg1)
        ret0, _ := ret[0].(*proto.RegisterResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Register indicates an expected call of Register.
func (mr *MockUserServerMockRecorder) Register(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockUserServer)(nil).Register), arg0, arg1)
}</span>

// mustEmbedUnimplementedUserServer mocks base method.
func (m *MockUserServer) mustEmbedUnimplementedUserServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedUserServer")
}</span>

// mustEmbedUnimplementedUserServer indicates an expected call of mustEmbedUnimplementedUserServer.
func (mr *MockUserServerMockRecorder) mustEmbedUnimplementedUserServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedUserServer", reflect.TypeOf((*MockUserServer)(nil).mustEmbedUnimplementedUserServer))
}</span>

// MockUnsafeUserServer is a mock of UnsafeUserServer interface.
type MockUnsafeUserServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeUserServerMockRecorder
        isgomock struct{}
}

// MockUnsafeUserServerMockRecorder is the mock recorder for MockUnsafeUserServer.
type MockUnsafeUserServerMockRecorder struct {
        mock *MockUnsafeUserServer
}

// NewMockUnsafeUserServer creates a new mock instance.
func NewMockUnsafeUserServer(ctrl *gomock.Controller) *MockUnsafeUserServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeUserServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeUserServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeUserServer) EXPECT() *MockUnsafeUserServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedUserServer mocks base method.
func (m *MockUnsafeUserServer) mustEmbedUnimplementedUserServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedUserServer")
}</span>

// mustEmbedUnimplementedUserServer indicates an expected call of mustEmbedUnimplementedUserServer.
func (mr *MockUnsafeUserServerMockRecorder) mustEmbedUnimplementedUserServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedUserServer", reflect.TypeOf((*MockUnsafeUserServer)(nil).mustEmbedUnimplementedUserServer))
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.8
//         protoc        v6.32.0
// source: api/user.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RegisterRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Login         string                 `protobuf:"bytes,1,opt,name=login,proto3" json:"login,omitempty"`
        Password      string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        mi := &amp;file_api_user_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_user_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_user_proto_rawDescGZIP(), []int{0}
}</span>

func (x *RegisterRequest) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        Salt          string                 `protobuf:"bytes,2,opt,name=salt,proto3" json:"salt,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RegisterResponse) Reset() <span class="cov0" title="0">{
        *x = RegisterResponse{}
        mi := &amp;file_api_user_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_user_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_user_proto_rawDescGZIP(), []int{1}
}</span>

func (x *RegisterResponse) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterResponse) GetSalt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Salt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Login         string                 `protobuf:"bytes,1,opt,name=login,proto3" json:"login,omitempty"`
        Password      string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        mi := &amp;file_api_user_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_user_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_user_proto_rawDescGZIP(), []int{2}
}</span>

func (x *LoginRequest) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        Salt          string                 `protobuf:"bytes,2,opt,name=salt,proto3" json:"salt,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        mi := &amp;file_api_user_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_user_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_user_proto_rawDescGZIP(), []int{3}
}</span>

func (x *LoginResponse) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetSalt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Salt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_api_user_proto protoreflect.FileDescriptor

const file_api_user_proto_rawDesc = "" +
        "\n" +
        "\x0eapi/user.proto\x12\x03api\"C\n" +
        "\x0fRegisterRequest\x12\x14\n" +
        "\x05login\x18\x01 \x01(\tR\x05login\x12\x1a\n" +
        "\bpassword\x18\x02 \x01(\tR\bpassword\"&lt;\n" +
        "\x10RegisterResponse\x12\x14\n" +
        "\x05token\x18\x01 \x01(\tR\x05token\x12\x12\n" +
        "\x04salt\x18\x02 \x01(\tR\x04salt\"@\n" +
        "\fLoginRequest\x12\x14\n" +
        "\x05login\x18\x01 \x01(\tR\x05login\x12\x1a\n" +
        "\bpassword\x18\x02 \x01(\tR\bpassword\"9\n" +
        "\rLoginResponse\x12\x14\n" +
        "\x05token\x18\x01 \x01(\tR\x05token\x12\x12\n" +
        "\x04salt\x18\x02 \x01(\tR\x04salt2o\n" +
        "\x04User\x127\n" +
        "\bRegister\x12\x14.api.RegisterRequest\x1a\x15.api.RegisterResponse\x12.\n" +
        "\x05Login\x12\x11.api.LoginRequest\x1a\x12.api.LoginResponseB\vZ\tpkg/protob\x06proto3"

var (
        file_api_user_proto_rawDescOnce sync.Once
        file_api_user_proto_rawDescData []byte
)

func file_api_user_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_user_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_user_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_user_proto_rawDesc), len(file_api_user_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_api_user_proto_rawDescData</span>
}

var file_api_user_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_api_user_proto_goTypes = []any{
        (*RegisterRequest)(nil),  // 0: api.RegisterRequest
        (*RegisterResponse)(nil), // 1: api.RegisterResponse
        (*LoginRequest)(nil),     // 2: api.LoginRequest
        (*LoginResponse)(nil),    // 3: api.LoginResponse
}
var file_api_user_proto_depIdxs = []int32{
        0, // 0: api.User.Register:input_type -&gt; api.RegisterRequest
        2, // 1: api.User.Login:input_type -&gt; api.LoginRequest
        1, // 2: api.User.Register:output_type -&gt; api.RegisterResponse
        3, // 3: api.User.Login:output_type -&gt; api.LoginResponse
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_api_user_proto_init() }</span>
func file_api_user_proto_init() <span class="cov0" title="0">{
        if File_api_user_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_user_proto_rawDesc), len(file_api_user_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_user_proto_goTypes,
                DependencyIndexes: file_api_user_proto_depIdxs,
                MessageInfos:      file_api_user_proto_msgTypes,
        }.Build()
        File_api_user_proto = out.File
        file_api_user_proto_goTypes = nil
        file_api_user_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: api/user.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        User_Register_FullMethodName = "/api.User/Register"
        User_Login_FullMethodName    = "/api.User/Login"
)

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
        Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
}

type userClient struct {
        cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient <span class="cov0" title="0">{
        return &amp;userClient{cc}
}</span>

func (c *userClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RegisterResponse)
        err := c.cc.Invoke(ctx, User_Register_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, User_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility.
type UserServer interface {
        Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServer struct{}

func (UnimplementedUserServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}</span>
func (UnimplementedUserServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {<span class="cov0" title="0">}</span>
func (UnimplementedUserServer) testEmbeddedByValue()              {<span class="cov0" title="0">}</span>

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
        mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedUserServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;User_ServiceDesc, srv)</span>
}

func _User_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServer).Register(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: User_Register_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServer).Register(ctx, req.(*RegisterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _User_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: User_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "api.User",
        HandlerType: (*UserServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Register",
                        Handler:    _User_Register_Handler,
                },
                {
                        MethodName: "Login",
                        Handler:    _User_Login_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api/user.proto",
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package usercontext

import (
        "context"
        "fmt"

        "github.com/google/uuid"
)

// ContextKey - тип ключа в передаваемом контексте
type ContextKey string

// UserIDContextKey - имя ключа пользователя в передаваемом контексте
var UserIDContextKey ContextKey = "userID"

// GetUserId - метод получает UUID пользователя из контекста
func GetUserId(ctx context.Context) (uuid.UUID, error) <span class="cov8" title="1">{
        var uid uuid.UUID
        userID := ctx.Value(UserIDContextKey)
        if userID == nil </span><span class="cov8" title="1">{
                return uid, fmt.Errorf("unknown user")
        }</span>
        <span class="cov8" title="1">uid, ok := userID.(uuid.UUID)
        if !ok </span><span class="cov8" title="1">{
                return uid, fmt.Errorf("invalid user")
        }</span>

        <span class="cov8" title="1">return uid, nil</span>
}

// SetUserId - метод устанавливает UUID пользователя в контекст
func SetUserId(ctx context.Context, uid uuid.UUID) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, UserIDContextKey, uid)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
